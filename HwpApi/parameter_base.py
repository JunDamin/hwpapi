# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_api/02_parameters.ipynb.

"""
Base classes and utilities for HWP parameter sets.
"""

from __future__ import annotations
from .functions import from_hwpunit, to_hwpunit, convert_hwp_color_to_hex, convert_to_hwp_color
from .parameter_mappings import ALL_MAPPINGS
import pprint
from typing import Any, Dict, List, Optional, Union, Callable, Type


class PropertyDescriptor:
    """Base descriptor for parameter properties."""
    
    def __init__(self, key: str, doc: str):
        self.key = key
        self.doc = doc
        self.name = None  # Will be set by __set_name__
    
    def __set_name__(self, owner, name):
        self.name = name
    
    def _get_value(self, instance):
        """Get a value from the parameter set."""
        if instance._is_pset:
            return instance._pset.Item(self.key)
        return getattr(instance._pset, self.key)
    
    def _set_value(self, instance, value):
        """Set a value in the parameter set."""
        if instance._is_pset:
            return instance._pset.SetItem(self.key, value)
        return setattr(instance._pset, self.key, value)
    
    def _del_value(self, instance):
        """Delete a value from the parameter set."""
        if instance._is_pset:
            return instance._pset.RemoveItem(self.key)
        return False


class IntProperty(PropertyDescriptor):
    """Property descriptor for integer values with optional range validation."""
    
    def __init__(self, key: str, doc: str, min_val: Optional[int] = None, max_val: Optional[int] = None):
        super().__init__(key, doc)
        self.min_val = min_val
        self.max_val = max_val
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return self._get_value(instance)
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        # Type validation
        if not isinstance(value, int):
            raise TypeError(f"Value for '{self.key}' must be an integer, got {type(value).__name__}")
        
        # Range validation
        if self.min_val is not None and value < self.min_val:
            raise ValueError(f"Value for '{self.key}' must be >= {self.min_val}, got {value}")
        if self.max_val is not None and value > self.max_val:
            raise ValueError(f"Value for '{self.key}' must be <= {self.max_val}, got {value}")
        
        return self._set_value(instance, value)


class BoolProperty(PropertyDescriptor):
    """Property descriptor for boolean values (0 or 1)."""
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return self._get_value(instance)
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        # Convert boolean to 0/1 if needed
        if isinstance(value, bool):
            value = int(value)
        
        # Validate value is 0 or 1
        if value not in [0, 1]:
            raise ValueError(f"Value for '{self.key}' must be 0 or 1, got {value}")
        
        return self._set_value(instance, value)


class StringProperty(PropertyDescriptor):
    """Property descriptor for string values."""
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return self._get_value(instance)
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        if not isinstance(value, str):
            raise TypeError(f"Value for '{self.key}' must be a string, got {type(value).__name__}")
        
        return self._set_value(instance, value)


class ColorProperty(PropertyDescriptor):
    """Property descriptor for color values with hex conversion."""
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        hwp_color = self._get_value(instance)
        return convert_hwp_color_to_hex(hwp_color)
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        hwp_color = convert_to_hwp_color(value)
        return self._set_value(instance, hwp_color)


class UnitProperty(PropertyDescriptor):
    """Property descriptor for unit-based values with automatic conversion."""
    
    def __init__(self, key: str, unit: str, doc: str):
        super().__init__(key, doc)
        self.unit = unit
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        hwp_value = self._get_value(instance)
        return from_hwpunit(hwp_value, self.unit)
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        # Type validation
        if not isinstance(value, (int, float)):
            raise TypeError(f"Value for '{self.key}' must be a number, got {type(value).__name__}")
        
        # Convert to HWP unit
        hwp_value = to_hwpunit(float(value), self.unit)
        return self._set_value(instance, hwp_value)


class MappedProperty(PropertyDescriptor):
    """Property descriptor for mapped values (string <-> integer)."""
    
    def __init__(self, key: str, mapping: Dict[str, int], doc: str):
        super().__init__(key, doc)
        self.mapping = mapping
        self.reverse_mapping = {v: k for k, v in mapping.items()}
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        numeric_value = self._get_value(instance)
        # Return the string representation if available, otherwise the numeric value
        return self.reverse_mapping.get(numeric_value, numeric_value)
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        # Handle string input
        if isinstance(value, str):
            if value not in self.mapping:
                valid_options = list(self.mapping.keys())
                raise ValueError(f"Invalid value '{value}' for '{self.key}'. Valid options: {valid_options}")
            numeric_value = self.mapping[value]
        
        # Handle integer input
        elif isinstance(value, int):
            if value not in self.reverse_mapping:
                valid_options = list(self.reverse_mapping.keys())
                raise ValueError(f"Invalid value {value} for '{self.key}'. Valid options: {valid_options}")
            numeric_value = value
        
        # Invalid type
        else:
            raise TypeError(f"Value for '{self.key}' must be string or integer, got {type(value).__name__}")
        
        return self._set_value(instance, numeric_value)


class TypedProperty(PropertyDescriptor):
    """Property descriptor for typed parameter sets."""
    
    def __init__(self, key: str, doc: str, expected_type: Callable):
        super().__init__(key, doc)
        self.expected_type = expected_type
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self._get_value(instance)
        if value is None:
            return None
        # Wrap in expected type if not already wrapped
        if not isinstance(value, self.expected_type()):
            return self.expected_type()(value)
        return value
    
    def __set__(self, instance, pset):
        if pset is None:
            return self._del_value(instance)
        
        # Validate type
        if not isinstance(pset, self.expected_type()):
            raise TypeError(f"Value for '{self.key}' must be of type {self.expected_type.__name__}")
        
        # Get or create target
        target = self._get_value(instance)
        if not target:
            target = instance._pset.CreateItemSet(self.key, self.expected_type().SetID)
        
        # Update target with new values
        self.expected_type()(target).update_from(pset)


class ListProperty(PropertyDescriptor):
    """Property descriptor for list values."""
    
    def __init__(self, key: str, doc: str, item_type: Optional[Type] = None, 
                 min_length: Optional[int] = None, max_length: Optional[int] = None):
        super().__init__(key, doc)
        self.item_type = item_type
        self.min_length = min_length
        self.max_length = max_length
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return self._get_value(instance)
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        # Validate list type
        if not isinstance(value, list):
            raise TypeError(f"Value for '{self.key}' must be a list, got {type(value).__name__}")
        
        # Length validation
        if self.min_length is not None and len(value) < self.min_length:
            raise ValueError(f"Length of '{self.key}' must be >= {self.min_length}, got {len(value)}")
        if self.max_length is not None and len(value) > self.max_length:
            raise ValueError(f"Length of '{self.key}' must be <= {self.max_length}, got {len(value)}")
        
        # Item type validation
        if self.item_type is not None:
            if self.item_type == int:
                if not all(isinstance(item, int) for item in value):
                    raise TypeError(f"All items in '{self.key}' must be integers")
            elif self.item_type == tuple:
                for i, item in enumerate(value):
                    if not isinstance(item, tuple) or len(item) != 2:
                        raise TypeError(f"Item {i} in '{self.key}' must be a tuple of length 2")
                    if not all(isinstance(coord, int) for coord in item):
                        raise TypeError(f"All coordinates in item {i} of '{self.key}' must be integers")
        
        return self._set_value(instance, value)


class ParameterSetMeta(type):
    """Metaclass for automatic property registration."""
    
    def __new__(cls, name, bases, namespace):
        # Collect property descriptors
        properties = {}
        for key, value in namespace.items():
            if isinstance(value, PropertyDescriptor):
                properties[key] = value
        
        # Create the class
        new_class = super().__new__(cls, name, bases, namespace)
        
        # Auto-generate attributes_names from property descriptors
        if properties and name != 'ParameterSet':
            # Get attributes_names from all property descriptors
            attribute_names = list(properties.keys())
            
            # Add any manually defined attributes_names
            if hasattr(new_class, '_additional_attributes'):
                attribute_names.extend(new_class._additional_attributes)
            
            new_class._property_names = attribute_names
        
        return new_class


class ParameterSet(metaclass=ParameterSetMeta):
    """
    Base class for HWP parameter sets.
    
    Provides a unified interface for working with HWP parameter objects,
    handling both COM objects with SetID and regular Python objects.
    """

    def __init__(self, parameterset):
        """Initialize with a parameter set object."""
        self._pset = parameterset
        self._is_pset = hasattr(parameterset, "SetID")
        # Use auto-generated property names or fall back to manual list
        self.attributes_names = getattr(self.__class__, '_property_names', [])

    @property
    def parameterset(self):
        """Get the underlying parameter set object."""
        return self._pset

    def _get_value(self, name):
        """Get a value from the parameter set."""
        if self._is_pset:
            return self._pset.Item(name)
        return getattr(self._pset, name)
    
    def _set_value(self, name, value):
        """Set a value in the parameter set."""
        if self._is_pset:
            return self._pset.SetItem(name, value)
        return setattr(self._pset, name, value)

    def _del_value(self, name):
        """Delete a value from the parameter set."""
        if self._is_pset:
            return self._pset.RemoveItem(name)
        return False
    
    def update_from(self, pset):
        """Update this parameter set with values from another parameter set."""
        for key in self.attributes_names:
            value = getattr(pset, key, None)
            
            if isinstance(value, ParameterSet):
                # Recursively update nested parameter sets
                target = getattr(self, key)
                target.update_from(value)
            elif value is None:
                # Remove the attribute if value is None
                self._del_value(key)
            elif value:
                # Set the attribute if value is truthy
                setattr(self, key, value)
        return self

    def serialize(self):
        """Convert the parameter set to a dictionary."""
        result = {}
        for key in self.attributes_names:
            value = getattr(self, key, None)
            if isinstance(value, ParameterSet):
                value = value.serialize()
            result[key] = value
        return result
    
    def __str__(self):
        """String representation of the parameter set."""
        data = {
            "name": self.__class__.__name__, 
            "values": self.serialize()
        }
        return pprint.pformat(data, indent=4, width=60)
    
    def __repr__(self):
        """Representation of the parameter set."""
        return self.__str__()

    # Legacy static methods for backward compatibility
    @staticmethod        
    def _typed_prop(key, doc, expected_type):
        """Create a property for typed parameter sets."""
        return TypedProperty(key, doc, expected_type)

    @staticmethod      
    def _int_prop(key, doc, min_val=None, max_val=None):
        """Create a property for integer values with optional range validation."""
        return IntProperty(key, doc, min_val, max_val)
    
    @staticmethod 
    def _bool_prop(key, doc):
        """Create a property for boolean values (0 or 1)."""
        return BoolProperty(key, doc)
    
    @staticmethod 
    def _color_prop(key, doc):
        """Create a property for color values with hex conversion."""
        return ColorProperty(key, doc)
    
    @staticmethod 
    def _unit_prop(key, unit, doc):
        """Create a property for unit-based values with automatic conversion."""
        return UnitProperty(key, unit, doc)
    
    @staticmethod 
    def _mapped_prop(key, mapping, doc):
        """Create a property for mapped values (string <-> integer)."""
        return MappedProperty(key, mapping, doc)

    @staticmethod
    def _str_prop(key, doc):
        """Create a property for string values."""
        return StringProperty(key, doc)

    @staticmethod
    def _int_list_prop(key, doc):
        """Create a property for lists of integers."""
        return ListProperty(key, doc, item_type=int)
    
    @staticmethod
    def _tuple_list_prop(key, doc):
        """Create a property for lists of (X, Y) coordinate tuples."""
        return ListProperty(key, doc, item_type=tuple)
    
    @staticmethod
    def _gradation_color_prop(key, doc):
        """Create a property for gradation color lists (2-10 colors)."""
        return ListProperty(key, doc, min_length=2, max_length=10)
