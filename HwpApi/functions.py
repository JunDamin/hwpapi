# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_api/02_functions.ipynb.

# %% auto #0
__all__ = ['logger', 'HWPUNIT_PER_MM', 'HWPUNIT_PER_PT', 'HWPUNIT_PER_CM', 'HWPUNIT_PER_INCH', 'get_font_name', 'dispatch',
           'get_hwp_objects', 'get_absolute_path', 'get_appdata_path', 'get_hwp_dll_path', 'get_dll_path',
           'add_dll_to_registry', 'get_registry_value', 'check_dll', 'get_value', 'get_key', 'convert2int', 'set_pset',
           'get_charshape_pset', 'set_charshape_pset', 'get_parashape_pset', 'set_parashape_pset', 'hex_to_rgb',
           'get_rgb_tuple', 'convert_to_hwp_color', 'convert_hwp_color_to_hex', 'mili2unit', 'unit2mili', 'point2unit',
           'unit2point', 'parse_unit_string', 'to_hwpunit', 'from_hwpunit', 'block_input']

# %% ../nbs/02_api/02_functions.ipynb #2ad3361d-2420-4fb6-ab7b-bb73f322e64c
import importlib.resources
import os
import shutil
import sys
import winreg
from pathlib import Path
import re
import win32com.client as win32 
import pythoncom 
import pywintypes
from win32com.client import Dispatch
from win32com import client

from .constants import char_fields, para_fields
from .logging import get_logger
logger = get_logger("functions")

# %% ../nbs/02_api/02_functions.ipynb #59da99a1-f3de-4c23-80f8-f04830ab36b6
def get_font_name(text):
    logger.debug(f"get_font_name called")
    logger.debug(f"Calling get_font_name")
    m = re.search("(^.+?)\s[A-Z0-9]+\.HFT", text)
    return m.group(1) if m else None

# %% ../nbs/02_api/02_functions.ipynb #eda59f13-c968-4c35-9449-07a187cfc746
def dispatch(app_name):
    """캐시가 충돌하는 문제를 해결하기 위해 실행합니다. 에러가 발생할 경우 기존 캐시를 삭제하고 다시 불러옵니다."""
    logger.debug(f"dispatch called")
    logger.debug(f"Attempting to dispatch: {app_name}")
    
    try:
        from win32com import client

        app = client.gencache.EnsureDispatch(app_name)
        logger.info(f"Successfully dispatched: {app_name}")
        return app
    except AttributeError as e:
        logger.warning(f"AttributeError occurred, clearing cache: {e}")
        # Corner case dependencies.
        import os
        import re
        import shutil
        import sys

        # Remove cache and try again.
        MODULE_LIST = [m.__name__ for m in sys.modules.values()]
        for module in MODULE_LIST:
            if re.match(r"win32com\.gen_py\..+", module):
                del sys.modules[module]
        
        cache_path = os.path.join(os.environ.get("LOCALAPPDATA"), "Temp", "gen_py")
        if os.path.exists(cache_path):
            shutil.rmtree(cache_path)
            logger.debug(f"Removed cache directory: {cache_path}")
        
        from win32com import client

        app = client.gencache.EnsureDispatch(app_name)
        logger.info(f"Successfully dispatched after cache clear: {app_name}")
        return app

# %% ../nbs/02_api/02_functions.ipynb #4fe74a22-8c1a-4f3e-a17c-1fa944a99c78
def get_hwp_objects():
    logger.debug(f"get_hwp_objects called")
    logger.debug("Searching for running HWP objects")
    
    hwp_objects = []
    
    try:
        context = pythoncom.CreateBindCtx(0)
        
        # 현재 실행중인 프로세스를 가져옵니다. 
        running_coms = pythoncom.GetRunningObjectTable()
        monikers = running_coms.EnumRunning()

        for moniker in monikers:
            try:
                name = moniker.GetDisplayName(context, moniker)
                # moniker의 DisplayName을 통해 한글을 가져옵니다
                # 한글의 경우 HwpObject.버전으로 각 버전별 실행 이름을 설정합니다. 
                if re.match("!HwpObject", name):
                    logger.debug(f"Found HWP object: {name}")
                    # 120은 한글 2022의 경우입니다. 
                    # 현재 moniker를 통해 ROT에서 한글의 object를 가져옵니다. 
                    try:
                        obje = running_coms.GetObject(moniker)
                        # 가져온 object를 Dispatch를 통해 사용할수 있는 객체로 변환시킵니다. 
                        hwp_obj = obje.QueryInterface(pythoncom.IID_IDispatch)
                        hwp_objects.append(hwp_obj)
                        logger.debug(f"Successfully added HWP object: {name}")
                    except pywintypes.com_error as e:
                        logger.warning(f"COM error when accessing object {name}: {e}")
                        continue
                    except Exception as e:
                        logger.warning(f"Unexpected error when accessing object {name}: {e}")
                        continue
            except pywintypes.com_error as e:
                logger.warning(f"COM error when processing moniker: {e}")
                continue
            except Exception as e:
                logger.warning(f"Unexpected error when processing moniker: {e}")
                continue
                
    except pywintypes.com_error as e:
        logger.error(f"COM error when accessing Running Object Table: {e}")
        return []
    except Exception as e:
        logger.error(f"Unexpected error when accessing Running Object Table: {e}")
        return []
    
    logger.info(f"Found {len(hwp_objects)} running HWP objects")
    return hwp_objects

# %% ../nbs/02_api/02_functions.ipynb #6f04ba42-85e9-4aed-a182-eb9a7b045b5f
def get_absolute_path(path):
    """파일 절대 경로를 반환합니다."""
    logger.debug(f"get_absolute_path called")
    logger.debug(f"Calling get_absolute_path")
    name = Path(path)
    return name.absolute().as_posix()

# %% ../nbs/02_api/02_functions.ipynb #appdata-path-cell
def get_appdata_path():
    """
    Get application data directory path for hwpapi.

    Returns:
        Path to hwpapi's appdata directory (created if not exists)
    """
    appdata = Path.home() / 'AppData' / 'Roaming' / 'hwpapi'
    appdata.mkdir(parents=True, exist_ok=True)
    logger.debug(f"AppData path: {appdata}")
    return appdata

# %% ../nbs/02_api/02_functions.ipynb #get-hwp-dll-path-cell
def get_hwp_dll_path():
    """
    Get path to HWP DLL, copying from bundle to appdata if needed.

    For PyInstaller distribution:
    - DLL is bundled in the executable (_MEIPASS) or package
    - On first run, copy to stable appdata location
    - Use appdata path for all operations (stable for COM registration)

    Returns:
        Path to DLL in appdata folder, or None if not found
    """
    DLL_NAME = 'FilePathCheckerModuleExample.dll'

    # Target location: appdata (stable path)
    appdata_dll = get_appdata_path() / DLL_NAME

    # If already in appdata, use it
    if appdata_dll.exists():
        logger.debug(f"DLL found in appdata: {appdata_dll}")
        return appdata_dll

    # Otherwise, find source and copy to appdata
    source_dll = None

    # 1. Check PyInstaller bundle (_MEIPASS)
    if hasattr(sys, '_MEIPASS'):
        # Check in hwpapi subfolder first (when hwpapi is a library)
        bundled = Path(sys._MEIPASS) / 'hwpapi' / DLL_NAME
        if bundled.exists():
            source_dll = bundled
            logger.debug(f"Found DLL in PyInstaller bundle (hwpapi/): {bundled}")
        else:
            # Check in root (when hwpapi is main app)
            bundled = Path(sys._MEIPASS) / DLL_NAME
            if bundled.exists():
                source_dll = bundled
                logger.debug(f"Found DLL in PyInstaller bundle (root): {bundled}")

    # 2. Check package directory (development or pip install)
    if source_dll is None:
        try:
            package_dll = Path(__file__).parent / DLL_NAME
            if package_dll.exists():
                source_dll = package_dll
                logger.debug(f"Found DLL in package directory: {package_dll}")
        except NameError:
            pass  # __file__ not defined in some contexts

    # 3. Try importlib.resources (pip installed package)
    if source_dll is None:
        try:
            with importlib.resources.path("hwpapi", DLL_NAME) as dll_path:
                if Path(dll_path).exists():
                    source_dll = Path(dll_path)
                    logger.debug(f"Found DLL via importlib.resources: {source_dll}")
        except (FileNotFoundError, TypeError):
            pass

    # Copy to appdata if found
    if source_dll is not None:
        try:
            appdata_dll.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(source_dll, appdata_dll)
            logger.info(f"Copied DLL to appdata: {appdata_dll}")
            return appdata_dll
        except Exception as e:
            logger.error(f"Failed to copy DLL to appdata: {e}")
            # Fall back to source location
            return source_dll

    logger.warning("DLL not found in any location")
    return None

# %% ../nbs/02_api/02_functions.ipynb #523811a2-7c18-4e4e-b7a1-92ab0eddb642
def get_dll_path(package_name, dll_filename):
    """패키지에서 dll 경로를 확보합니다."""
    logger.debug(f"get_dll_path called")
    logger.debug(f"Calling get_dll_path")
    try:
        with importlib.resources.path(package_name, dll_filename) as dll_path:
            return str(dll_path)
    except FileNotFoundError as e:
        raise FileNotFoundError(
            f"The DLL file '{dll_filename}' was not found in the package '{package_name}'."
        ) from e

# %% ../nbs/02_api/02_functions.ipynb #86241da9-ff8a-4a59-8b62-8e1c3a6f6cea
def add_dll_to_registry(dll_path, key_path):
    """레지스트리에 dll을 등록합니다."""
    logger.debug(f"add_dll_to_registry called")
    logger.debug(f"Calling add_dll_to_registry")
    try:
        # Connect to the registry and open the specified key
        registry_key = winreg.OpenKey(
            winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE
        )

    # Convert Path -> str
    if isinstance(dll_path, Path):
        dll_path = str(dll_path)

    # Convert bytes -> decode (if that happens in your pipeline)
    if isinstance(dll_path, (bytes, bytearray)):
        dll_path = dll_path.decode("utf-8", errors="strict")

    # Ensure final type is str
    if not isinstance(dll_path, str):
        dll_path = str(dll_path)

    dll_path = dll_path.strip()
    # Expand env vars like %USERPROFILE%
    dll_path = os.path.expandvars(dll_path)

    return dll_path

# %% ../nbs/02_api/02_functions.ipynb #64f0f323-fefa-442c-a6f8-437c4b9252a0
def get_registry_value(key_path, value_name):
    """레지스트리에 값이 있는지 확인해 봅니다."""
    logger.debug(f"get_registry_value called")
    logger.debug(f"Calling get_registry_value")
    try:
        # Create/open the key (creates if missing)
        with winreg.CreateKeyEx(
            winreg.HKEY_CURRENT_USER,
            key_path,
            0,
            access=winreg.KEY_SET_VALUE | winreg.KEY_QUERY_VALUE
        ) as key:
            winreg.SetValueEx(key, value_name, 0, winreg.REG_SZ, dll_path)

        logger.info(f"Registry updated: {key_path}\\{value_name} = {dll_path}")
        return True

    except OSError as e:
        logger.exception("Error while adding/updating DLL path to registry")
        print("Error while adding/updating DLL path to registry:", e)
        return False


# %% ../nbs/02_api/02_functions.ipynb 11
def get_registry_value(key_path, value_name=VALUE_NAME):
    """레지스트리에 값이 있는지 확인해 봅니다."""
    logger.debug("get_registry_value called")

    try:
        with winreg.OpenKey(
            winreg.HKEY_CURRENT_USER,
            key_path,
            0,
            winreg.KEY_QUERY_VALUE
        ) as key:
            value, _ = winreg.QueryValueEx(key, value_name)
            return value
    except FileNotFoundError:
        return None

# %% ../nbs/02_api/02_functions.ipynb #1215c8e8-a891-4ade-8743-2520157c387c
def check_dll(dll_path=None):
    """
    Register DLL module in Windows registry.

    If dll_path is not provided, automatically finds and copies DLL to
    stable AppData location for reliable PyInstaller support.
    """
    logger.debug("check_dll called")

    # Get stable DLL path (copies to appdata if needed)
    if dll_path is None:
        dll_path = get_hwp_dll_path()

    if dll_path is None:
        logger.error("DLL not found - cannot register")
        return False

    dll_path = str(dll_path)  # Ensure string for registry

    key_path = "SOFTWARE\\HNC\\HwpAutomation\\Modules"
    value_name = "FilePathCheckerModule"

    # Check current registry value
    current_value = get_registry_value(key_path, value_name)

    # Update if different or not set
    if current_value != dll_path:
        logger.info(f"Updating registry: {dll_path}")
        add_dll_to_registry(dll_path, key_path)
    else:
        logger.debug(f"Registry already correct: {dll_path}")

    return True

# %% ../nbs/02_api/02_functions.ipynb #75620557-aef7-4c2a-9196-d9588d3ac016
def get_value(dict_, key):
    """딕셔너리에서 키를 찾아 값을 반환합니다. 반환할 값이 없으면 키에러와 함께 가능한 키를 알려줍니다."""
    logger.debug(f"get_value called")
    logger.debug(f"Calling get_value")
    if key is None:
        return None
    try:
        return dict_[key]
    except KeyError:
        raise KeyError(
            f"{key}를 해당하는 키 중 찾을 수 없습니다. 키는 {', '.join(dict_.keys())} 중에 있어야 합니다."
        )

# %% ../nbs/02_api/02_functions.ipynb #7f84ed1e-2b32-4e18-9886-5dcaab8ef2b3
def get_key(dict_, value):
    """딕셔너리에서 값를 찾아 키를 반환합니다. 반환할 값이 없으면 키에러와 함께 가능한 키를 알려줍니다."""
    logger.debug(f"get_key called")
    logger.debug(f"Calling get_key")
    if value is None:
        return None
    try:
        return dict([(v, k) for k, v in dict_.items()])[value]
    except KeyError:
        raise KeyError(
            f"{value}를 해당하는 키 중 찾을 수 없습니다. 키는 {', '.join(dict_.values())} 중에 있어야 합니다."
        )

# %% ../nbs/02_api/02_functions.ipynb #3196074d-d81d-4bad-a73d-f6765bedfaec
def convert2int(_dict, value):
    logger.debug(f"convert2int called")
    logger.debug(f"Calling convert2int")
    if value is None:
        return value
    if isinstance(value, str):
        return get_value(_dict, value)
    if isinstance(value, int):
        return value
    if isinstance(value, float):
        return int(value)

# %% ../nbs/02_api/02_functions.ipynb #094e8ea5-6fbf-4266-8875-7b66bb7535d0
def set_pset(p, value_dict:dict):
    logger.debug(f"set_pset called")
    logger.debug(f"Calling set_pset")
    for field in dir(p):
        value = value_dict.get(field, None)
        if value is None:
            continue
        setattr(p, field, value)

    return p

# %% ../nbs/02_api/02_functions.ipynb #64dbbb52-4b23-4d17-b231-0beff1f1a37b
def get_charshape_pset(p):
    logger.debug(f"get_charshape_pset called")
    logger.debug(f"Calling get_charshape_pset")
    return {field: getattr(p, field) for field in char_fields}

# %% ../nbs/02_api/02_functions.ipynb #e4c347ca-bc90-4cc1-b4ac-c1f36eb6546e
def set_charshape_pset(
    charshape_pset, value_dict:dict
):
    """
    CharShape값을 입력하기 위한 함수입니다.
    char_fields에 정의된 키 값을 기반으로 파라미터를 세팅합니다.
    """
    
    
    logger.debug(f"Calling set_charshape_pset")

    for field in char_fields:
        value = value_dict.get(field, None)
        if not value:
            continue
        setattr(charshape_pset, field, value)

    return charshape_pset

# %% ../nbs/02_api/02_functions.ipynb #a1c9b3f5-2f5f-4e73-98eb-df28d3ed5d1e
def get_parashape_pset(p):

    logger.debug(f"get_parashape_pset called")
    logger.debug(f"Calling get_parashape_pset")
    return {field: getattr(p, field) for field in para_fields}

# %% ../nbs/02_api/02_functions.ipynb #6cfb628b-0c02-48cb-b245-b4782ad532c1
def set_parashape_pset(
    parashape_pset, value_dict:dict,
):

    
    logger.debug(f"Calling set_parashape_pset")
 
    for field in para_fields:
        value = value_dict.get(field, None)
        if not value:
            continue
        setattr(parashape_pset, field, value)

    
    return parashape_pset

# %% ../nbs/02_api/02_functions.ipynb #2bbd003f-52c6-4106-b942-b7dfe70d5d5c
def hex_to_rgb(hex_string):
    # Remove the "#" symbol if it exists
    logger.debug(f"hex_to_rgb called")
    logger.debug(f"Calling hex_to_rgb")
    if hex_string.startswith("#"):
        hex_string = hex_string[1:]

    # Convert the hex string to decimal integers
    red = int(hex_string[0:2], 16)
    green = int(hex_string[2:4], 16)
    blue = int(hex_string[4:], 16)

    # Return the RGB tuple
    return (red, green, blue)


def get_rgb_tuple(color):
    # check if the input is already a tuple
    logger.debug(f"get_rgb_tuple called")
    if isinstance(color, tuple):
        # validate each color
        if len(color) > 3:
            raise ValueError(
                f"colors should contains three compoents which represents RGB"
            )

        for component in color:
            if component > 255:
                raise ValueError(
                    f"number should be smaller than 255. the value is {color}"
                )
        return color

    # if the input is a string, split it into a list of colors
    elif isinstance(color, str):
        colors = {
            "red": (255, 0, 0),
            "green": (0, 255, 0),
            "blue": (0, 0, 255),
            "black": (0, 0, 0),
            "white": (255, 255, 255),
        }

        if color in colors.keys():
            return colors.get(color)

        # validate each color
        if not (
            color.startswith("#")
            and len(color) == 7
            and all(c in "0123456789abcdefABCDEF" for c in color[1:])
        ):
            raise ValueError(f"'{color}' is not a valid hexadecimal color.")

        # convert the list to a tuple and return it
        return hex_to_rgb(color)

    else:
        raise TypeError("Input must be a string or a tuple of colors.")

# %% ../nbs/02_api/02_functions.ipynb #ea3a8ee2-924a-4eef-b46b-cf7442408701
def convert_to_hwp_color(color):
    
    logger.debug(f"convert_to_hwp_color called")
    logger.debug(f"Calling convert_to_hwp_color")
    if isinstance(color, int):
        return color 
    
    if isinstance(color, str):  # if the color is a string, we assume it's a hex string
        #hwp use bgr order
        colors = {
            "red": "0000FF",
            "green": "00FF00",
            "blue": "FF0000",
            "black": "000000",
            "white": "FFFFFF",
        }
            
        if color in colors.keys():
            return int(colors.get(color), 16)
        
        # handle hex
        m = re.search("^#?([0-9A-Fa-f]{6})$", color)
        if m:
            color = m.group(1)
            return int(f"{color[4:6]}{color[2:4]}{color[0:2]}", 16)
        
    elif type(color) == tuple and len(color) == 3:  # if the color is a tuple, we assume it's an (R,G,B) tuple
        return color[2]*65536 + color[1]*256 + color[0]
    else:
        raise ValueError(f"Unsupported color format: {color}")

# %% ../nbs/02_api/02_functions.ipynb #258d3a35-8ad7-41c0-95a7-764d1ba2451f
def convert_hwp_color_to_hex(color:int):
    logger.debug(f"convert_hwp_color_to_hex called")
    logger.debug(f"Calling convert_hwp_color_to_hex")
    if not color:
        return color
    text = f"{color:06x}"
    return f"#{text[4:6]}{text[2:4]}{text[:2]}"

# %% ../nbs/02_api/02_functions.ipynb #3b69ad8c-2b3e-44dc-9c58-45dafb2fd102
def mili2unit(value):
    """
    logger.debug(f"mili2unit called")
    1 밀리는 283 hwpunit 입니다.
    """
    logger.debug(f"Calling mili2unit")
    return int(round(value*283, 0)) if value else value

# %% ../nbs/02_api/02_functions.ipynb #87b0a065-7cf7-4e30-a3fc-151af973c5e7
def unit2mili(value):
    logger.debug(f"unit2mili called")
    logger.debug(f"Calling unit2mili")
    return value/283 if value else value

# %% ../nbs/02_api/02_functions.ipynb #2f3841ea-487a-4e27-a473-57bdf4928591
def point2unit(value):
    """
    logger.debug(f"point2unit called")
    1point는 100 hwpunit입니다.
    """
    logger.debug(f"Calling point2unit")
    return int(round(value*100, 0)) if value else value

# %% ../nbs/02_api/02_functions.ipynb #c5dfe4ac-8ba8-4fa9-b04d-c8f4a891f256
def unit2point(value):
    logger.debug(f"unit2point called")
    logger.debug(f"Calling unit2point")
    return value / 100 if value else value

# %% ../nbs/02_api/02_functions.ipynb #9aeac8f6
from typing import Union, Tuple

# Unit conversion constants
HWPUNIT_PER_MM = 283
HWPUNIT_PER_PT = 100
HWPUNIT_PER_CM = 2830
HWPUNIT_PER_INCH = 7200  # 1 inch = 25.4mm * 283


def parse_unit_string(value: Union[str, int, float], default_unit: str = "mm") -> Tuple[float, str]:
    """
    Parse a value with optional unit suffix.

    Args:
        value: Number or string like "210mm", "21cm", "8.27in", "100pt"
        default_unit: Unit to assume if value is numeric (default: "mm")

    Returns:
        (numeric_value, unit)

    Examples:
        >>> parse_unit_string("210mm")
        (210.0, "mm")
        >>> parse_unit_string("21cm")
        (21.0, "cm")
        >>> parse_unit_string(210)
        (210.0, "mm")  # default unit
    """
    
    if isinstance(value, (int, float)):
        return (float(value), default_unit)

    if isinstance(value, str):
        # Try to parse unit suffix
        match = re.match(r'^([0-9.]+)\s*(mm|cm|in|inch|pt|point)?$', value.lower().strip())
        if match:
            number = float(match.group(1))
            unit = match.group(2) or default_unit
            # Normalize unit names
            if unit in ['inch']:
                unit = 'in'
            elif unit in ['point']:
                unit = 'pt'
            logger.debug(f"Parsed: number={number}, unit={unit}")
            return (number, unit)

    raise ValueError(f"Invalid unit value: {value}")


def to_hwpunit(value: Union[str, int, float], default_unit: str = "mm") -> int:
    """
    Convert any unit to HWPUNIT.

    Args:
        value: Number or string with unit ("210mm", "21cm", 210, etc.)
        default_unit: Unit to assume for bare numbers

    Returns:
        HWPUNIT value (integer)

    Examples:
        >>> to_hwpunit("210mm")
        59430  # 210 * 283
        >>> to_hwpunit("21cm")
        59430  # 21 * 2830
        >>> to_hwpunit(210)  # assumes mm
        59430
    """
    
    number, unit = parse_unit_string(value, default_unit)

    conversions = {
        'mm': HWPUNIT_PER_MM,
        'cm': HWPUNIT_PER_CM,
        'in': HWPUNIT_PER_INCH,
        'pt': HWPUNIT_PER_PT,
    }

    if unit not in conversions:
        raise ValueError(f"Unknown unit: {unit}. Supported: mm, cm, in, pt")

    result = int(round(number * conversions[unit]))
    return result

    
def from_hwpunit(hwpunit_value: int, target_unit: str = "mm") -> float:
    """
    Convert HWPUNIT to specified unit.

    Args:
        hwpunit_value: Value in HWPUNIT
        target_unit: Desired output unit ("mm", "cm", "in", "pt")

    Returns:
        Value in target unit

    Examples:
        >>> from_hwpunit(59430, "mm")
        210.0
        >>> from_hwpunit(59430, "cm")
        21.0
    """
    
    conversions = {
        'mm': HWPUNIT_PER_MM,
        'cm': HWPUNIT_PER_CM,
        'in': HWPUNIT_PER_INCH,
        'pt': HWPUNIT_PER_PT,
    }

    if target_unit not in conversions:
        raise ValueError(f"Unknown unit: {target_unit}. Supported: mm, cm, in, pt")

    result = round(hwpunit_value / conversions[target_unit], 2)
    return result

# %% ../nbs/02_api/02_functions.ipynb #6d615fed
def block_input(func):
    """
    logger.debug(f"block_input called")
    함수가 실행될 동안 다른 입력을 할 수 없게 하는 기능을 가진 데코레이터입니다. 
    """
    logger.debug(f"Calling block_input")
    def wrapper(app, *args, **kwargs):
        logger.debug(f"wrapper called")
        app.api.EditMode = 0
        result = func(app, *args, **kwargs)
        app.api.EditMode = 1
        return result
    return wrapper
