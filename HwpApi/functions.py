# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_api/02_functions.ipynb.

# %% auto 0
__all__ = ['logger', 'HWPUNIT_PER_MM', 'HWPUNIT_PER_PT', 'HWPUNIT_PER_CM', 'HWPUNIT_PER_INCH', 'get_font_name', 'dispatch',
           'get_hwp_objects', 'get_absolute_path', 'get_dll_path', 'add_dll_to_registry', 'get_registry_value',
           'check_dll', 'get_value', 'get_key', 'convert2int', 'set_pset', 'get_charshape_pset', 'set_charshape_pset',
           'get_parashape_pset', 'set_parashape_pset', 'hex_to_rgb', 'get_rgb_tuple', 'convert_to_hwp_color',
           'convert_hwp_color_to_hex', 'mili2unit', 'unit2mili', 'point2unit', 'unit2point', 'parse_unit_string',
           'to_hwpunit', 'from_hwpunit', 'block_input']

# %% ../nbs/02_api/02_functions.ipynb 3
import importlib.resources
import os
import shutil
import winreg
from pathlib import Path
import re
import win32com.client as win32 
import pythoncom 
import pywintypes
from win32com.client import Dispatch
from win32com import client

from .constants import char_fields, para_fields
from .logging import get_logger
logger = get_logger("functions")

# %% ../nbs/02_api/02_functions.ipynb 4
def get_font_name(text):
    logger.debug(f"get_font_name called")
    logger.debug(f"Calling get_font_name")
    m = re.search("(^.+?)\s[A-Z0-9]+\.HFT", text)
    return m.group(1) if m else None

# %% ../nbs/02_api/02_functions.ipynb 5
def dispatch(app_name):
    """캐시가 충돌하는 문제를 해결하기 위해 실행합니다. 에러가 발생할 경우 기존 캐시를 삭제하고 다시 불러옵니다."""
    logger.debug(f"dispatch called")
    logger.debug(f"Attempting to dispatch: {app_name}")
    
    try:
        from win32com import client

        app = client.gencache.EnsureDispatch(app_name)
        logger.info(f"Successfully dispatched: {app_name}")
        return app
    except AttributeError as e:
        logger.warning(f"AttributeError occurred, clearing cache: {e}")
        # Corner case dependencies.
        import os
        import re
        import shutil
        import sys

        # Remove cache and try again.
        MODULE_LIST = [m.__name__ for m in sys.modules.values()]
        for module in MODULE_LIST:
            if re.match(r"win32com\.gen_py\..+", module):
                del sys.modules[module]
        
        cache_path = os.path.join(os.environ.get("LOCALAPPDATA"), "Temp", "gen_py")
        if os.path.exists(cache_path):
            shutil.rmtree(cache_path)
            logger.debug(f"Removed cache directory: {cache_path}")
        
        from win32com import client

        app = client.gencache.EnsureDispatch(app_name)
        logger.info(f"Successfully dispatched after cache clear: {app_name}")
        return app

# %% ../nbs/02_api/02_functions.ipynb 6
def get_hwp_objects():
    logger.debug(f"get_hwp_objects called")
    logger.debug("Searching for running HWP objects")
    
    hwp_objects = []
    
    try:
        context = pythoncom.CreateBindCtx(0)
        
        # 현재 실행중인 프로세스를 가져옵니다. 
        running_coms = pythoncom.GetRunningObjectTable()
        monikers = running_coms.EnumRunning()

        for moniker in monikers:
            try:
                name = moniker.GetDisplayName(context, moniker)
                # moniker의 DisplayName을 통해 한글을 가져옵니다
                # 한글의 경우 HwpObject.버전으로 각 버전별 실행 이름을 설정합니다. 
                if re.match("!HwpObject", name):
                    logger.debug(f"Found HWP object: {name}")
                    # 120은 한글 2022의 경우입니다. 
                    # 현재 moniker를 통해 ROT에서 한글의 object를 가져옵니다. 
                    try:
                        obje = running_coms.GetObject(moniker)
                        # 가져온 object를 Dispatch를 통해 사용할수 있는 객체로 변환시킵니다. 
                        hwp_obj = obje.QueryInterface(pythoncom.IID_IDispatch)
                        hwp_objects.append(hwp_obj)
                        logger.debug(f"Successfully added HWP object: {name}")
                    except pywintypes.com_error as e:
                        logger.warning(f"COM error when accessing object {name}: {e}")
                        continue
                    except Exception as e:
                        logger.warning(f"Unexpected error when accessing object {name}: {e}")
                        continue
            except pywintypes.com_error as e:
                logger.warning(f"COM error when processing moniker: {e}")
                continue
            except Exception as e:
                logger.warning(f"Unexpected error when processing moniker: {e}")
                continue
                
    except pywintypes.com_error as e:
        logger.error(f"COM error when accessing Running Object Table: {e}")
        return []
    except Exception as e:
        logger.error(f"Unexpected error when accessing Running Object Table: {e}")
        return []
    
    logger.info(f"Found {len(hwp_objects)} running HWP objects")
    return hwp_objects

# %% ../nbs/02_api/02_functions.ipynb 7
def get_absolute_path(path):
    """파일 절대 경로를 반환합니다."""
    logger.debug(f"get_absolute_path called")
    logger.debug(f"Calling get_absolute_path")
    name = Path(path)
    return name.absolute().as_posix()

# %% ../nbs/02_api/02_functions.ipynb 8
def get_dll_path(package_name, dll_filename):
    """패키지에서 dll 경로를 확보합니다."""
    logger.debug(f"get_dll_path called")
    logger.debug(f"Calling get_dll_path")
    try:
        with importlib.resources.path(package_name, dll_filename) as dll_path:
            return str(dll_path)
    except FileNotFoundError as e:
        raise FileNotFoundError(
            f"The DLL file '{dll_filename}' was not found in the package '{package_name}'."
        ) from e

# %% ../nbs/02_api/02_functions.ipynb 9
def add_dll_to_registry(dll_path, key_path):
    """레지스트리에 dll을 등록합니다."""
    logger.debug(f"add_dll_to_registry called")
    logger.debug(f"Calling add_dll_to_registry")
    try:
        # Connect to the registry and open the specified key
        registry_key = winreg.OpenKey(
            winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE
        )

        # Set the value for the new registry entry as a string (REG_SZ)
        winreg.SetValueEx(
            registry_key, "FilePathCheckerModule", 0, winreg.REG_SZ, dll_path
        )

        # Close the registry key
        winreg.CloseKey(registry_key)
        print("DLL path added to registry as a string value successfully.")
    except WindowsError as e:
        print("Error while adding DLL path to registry: ", e)

# %% ../nbs/02_api/02_functions.ipynb 10
def get_registry_value(key_path, value_name):
    """레지스트리에 값이 있는지 확인해 봅니다."""
    logger.debug(f"get_registry_value called")
    logger.debug(f"Calling get_registry_value")
    try:
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path) as key:
            value, value_type = winreg.QueryValueEx(key, value_name)
            return value
    except FileNotFoundError:
        return None

# %% ../nbs/02_api/02_functions.ipynb 11
def check_dll(dll_path=None):
    """dll 모듈을 등록합니다."""
    logger.debug(f"check_dll called")
    logger.debug(f"Calling check_dll")
    dll_path = dll_path if dll_path else get_dll_path("hwpapi", "FilePathCheckerModuleExample.dll")
    key_path = "SOFTWARE\\HNC\\HwpAutomation\\Modules"
    value_name = "FilePathCheckerModule"

    value = get_registry_value(key_path, value_name)

    if value is None:
        add_dll_to_registry(dll_path, key_path)
    return True

# %% ../nbs/02_api/02_functions.ipynb 12
def get_value(dict_, key):
    """딕셔너리에서 키를 찾아 값을 반환합니다. 반환할 값이 없으면 키에러와 함께 가능한 키를 알려줍니다."""
    logger.debug(f"get_value called")
    logger.debug(f"Calling get_value")
    if key is None:
        return None
    try:
        return dict_[key]
    except KeyError:
        raise KeyError(
            f"{key}를 해당하는 키 중 찾을 수 없습니다. 키는 {', '.join(dict_.keys())} 중에 있어야 합니다."
        )

# %% ../nbs/02_api/02_functions.ipynb 13
def get_key(dict_, value):
    """딕셔너리에서 값를 찾아 키를 반환합니다. 반환할 값이 없으면 키에러와 함께 가능한 키를 알려줍니다."""
    logger.debug(f"get_key called")
    logger.debug(f"Calling get_key")
    if value is None:
        return None
    try:
        return dict([(v, k) for k, v in dict_.items()])[value]
    except KeyError:
        raise KeyError(
            f"{value}를 해당하는 키 중 찾을 수 없습니다. 키는 {', '.join(dict_.values())} 중에 있어야 합니다."
        )

# %% ../nbs/02_api/02_functions.ipynb 14
def convert2int(_dict, value):
    logger.debug(f"convert2int called")
    logger.debug(f"Calling convert2int")
    if value is None:
        return value
    if isinstance(value, str):
        return get_value(_dict, value)
    if isinstance(value, int):
        return value
    if isinstance(value, float):
        return int(value)

# %% ../nbs/02_api/02_functions.ipynb 15
def set_pset(p, value_dict:dict):
    logger.debug(f"set_pset called")
    logger.debug(f"Calling set_pset")
    for field in dir(p):
        value = value_dict.get(field, None)
        if value is None:
            continue
        setattr(p, field, value)

    return p

# %% ../nbs/02_api/02_functions.ipynb 16
def get_charshape_pset(p):
    logger.debug(f"get_charshape_pset called")
    logger.debug(f"Calling get_charshape_pset")
    return {field: getattr(p, field) for field in char_fields}

# %% ../nbs/02_api/02_functions.ipynb 17
def set_charshape_pset(
    charshape_pset, value_dict:dict
):
    """
    CharShape값을 입력하기 위한 함수입니다.
    char_fields에 정의된 키 값을 기반으로 파라미터를 세팅합니다.
    """
    
    
    logger.debug(f"Calling set_charshape_pset")

    for field in char_fields:
        value = value_dict.get(field, None)
        if not value:
            continue
        setattr(charshape_pset, field, value)

    return charshape_pset

# %% ../nbs/02_api/02_functions.ipynb 18
def get_parashape_pset(p):

    logger.debug(f"get_parashape_pset called")
    logger.debug(f"Calling get_parashape_pset")
    return {field: getattr(p, field) for field in para_fields}

# %% ../nbs/02_api/02_functions.ipynb 19
def set_parashape_pset(
    parashape_pset, value_dict:dict,
):

    
    logger.debug(f"Calling set_parashape_pset")
 
    for field in para_fields:
        value = value_dict.get(field, None)
        if not value:
            continue
        setattr(parashape_pset, field, value)

    
    return parashape_pset

# %% ../nbs/02_api/02_functions.ipynb 20
def hex_to_rgb(hex_string):
    # Remove the "#" symbol if it exists
    logger.debug(f"hex_to_rgb called")
    logger.debug(f"Calling hex_to_rgb")
    if hex_string.startswith("#"):
        hex_string = hex_string[1:]

    # Convert the hex string to decimal integers
    red = int(hex_string[0:2], 16)
    green = int(hex_string[2:4], 16)
    blue = int(hex_string[4:], 16)

    # Return the RGB tuple
    return (red, green, blue)


def get_rgb_tuple(color):
    # check if the input is already a tuple
    logger.debug(f"get_rgb_tuple called")
    if isinstance(color, tuple):
        # validate each color
        if len(color) > 3:
            raise ValueError(
                f"colors should contains three compoents which represents RGB"
            )

        for component in color:
            if component > 255:
                raise ValueError(
                    f"number should be smaller than 255. the value is {color}"
                )
        return color

    # if the input is a string, split it into a list of colors
    elif isinstance(color, str):
        colors = {
            "red": (255, 0, 0),
            "green": (0, 255, 0),
            "blue": (0, 0, 255),
            "black": (0, 0, 0),
            "white": (255, 255, 255),
        }

        if color in colors.keys():
            return colors.get(color)

        # validate each color
        if not (
            color.startswith("#")
            and len(color) == 7
            and all(c in "0123456789abcdefABCDEF" for c in color[1:])
        ):
            raise ValueError(f"'{color}' is not a valid hexadecimal color.")

        # convert the list to a tuple and return it
        return hex_to_rgb(color)

    else:
        raise TypeError("Input must be a string or a tuple of colors.")

# %% ../nbs/02_api/02_functions.ipynb 21
def convert_to_hwp_color(color):
    
    logger.debug(f"convert_to_hwp_color called")
    logger.debug(f"Calling convert_to_hwp_color")
    if isinstance(color, int):
        return color 
    
    if isinstance(color, str):  # if the color is a string, we assume it's a hex string
        #hwp use bgr order
        colors = {
            "red": "0000FF",
            "green": "00FF00",
            "blue": "FF0000",
            "black": "000000",
            "white": "FFFFFF",
        }
            
        if color in colors.keys():
            return int(colors.get(color), 16)
        
        # handle hex
        m = re.search("^#?([0-9A-Fa-f]{6})$", color)
        if m:
            color = m.group(1)
            return int(f"{color[4:6]}{color[2:4]}{color[0:2]}", 16)
        
    elif type(color) == tuple and len(color) == 3:  # if the color is a tuple, we assume it's an (R,G,B) tuple
        return color[2]*65536 + color[1]*256 + color[0]
    else:
        raise ValueError(f"Unsupported color format: {color}")

# %% ../nbs/02_api/02_functions.ipynb 22
def convert_hwp_color_to_hex(color:int):
    logger.debug(f"convert_hwp_color_to_hex called")
    logger.debug(f"Calling convert_hwp_color_to_hex")
    if not color:
        return color
    text = f"{color:06x}"
    return f"#{text[4:6]}{text[2:4]}{text[:2]}"

# %% ../nbs/02_api/02_functions.ipynb 24
def mili2unit(value):
    """
    logger.debug(f"mili2unit called")
    1 밀리는 283 hwpunit 입니다.
    """
    logger.debug(f"Calling mili2unit")
    return int(round(value*283, 0)) if value else value

# %% ../nbs/02_api/02_functions.ipynb 25
def unit2mili(value):
    logger.debug(f"unit2mili called")
    logger.debug(f"Calling unit2mili")
    return value/283 if value else value

# %% ../nbs/02_api/02_functions.ipynb 26
def point2unit(value):
    """
    logger.debug(f"point2unit called")
    1point는 100 hwpunit입니다.
    """
    logger.debug(f"Calling point2unit")
    return int(round(value*100, 0)) if value else value

# %% ../nbs/02_api/02_functions.ipynb 27
def unit2point(value):
    logger.debug(f"unit2point called")
    logger.debug(f"Calling unit2point")
    return value / 100 if value else value

# %% ../nbs/02_api/02_functions.ipynb 28
from typing import Union, Tuple

# Unit conversion constants
HWPUNIT_PER_MM = 283
HWPUNIT_PER_PT = 100
HWPUNIT_PER_CM = 2830
HWPUNIT_PER_INCH = 7200  # 1 inch = 25.4mm * 283


def parse_unit_string(value: Union[str, int, float], default_unit: str = "mm") -> Tuple[float, str]:
    """
    Parse a value with optional unit suffix.

    Args:
        value: Number or string like "210mm", "21cm", "8.27in", "100pt"
        default_unit: Unit to assume if value is numeric (default: "mm")

    Returns:
        (numeric_value, unit)

    Examples:
        >>> parse_unit_string("210mm")
        (210.0, "mm")
        >>> parse_unit_string("21cm")
        (21.0, "cm")
        >>> parse_unit_string(210)
        (210.0, "mm")  # default unit
    """
    
    if isinstance(value, (int, float)):
        return (float(value), default_unit)

    if isinstance(value, str):
        # Try to parse unit suffix
        match = re.match(r'^([0-9.]+)\s*(mm|cm|in|inch|pt|point)?$', value.lower().strip())
        if match:
            number = float(match.group(1))
            unit = match.group(2) or default_unit
            # Normalize unit names
            if unit in ['inch']:
                unit = 'in'
            elif unit in ['point']:
                unit = 'pt'
            logger.debug(f"Parsed: number={number}, unit={unit}")
            return (number, unit)

    raise ValueError(f"Invalid unit value: {value}")


def to_hwpunit(value: Union[str, int, float], default_unit: str = "mm") -> int:
    """
    Convert any unit to HWPUNIT.

    Args:
        value: Number or string with unit ("210mm", "21cm", 210, etc.)
        default_unit: Unit to assume for bare numbers

    Returns:
        HWPUNIT value (integer)

    Examples:
        >>> to_hwpunit("210mm")
        59430  # 210 * 283
        >>> to_hwpunit("21cm")
        59430  # 21 * 2830
        >>> to_hwpunit(210)  # assumes mm
        59430
    """
    
    number, unit = parse_unit_string(value, default_unit)

    conversions = {
        'mm': HWPUNIT_PER_MM,
        'cm': HWPUNIT_PER_CM,
        'in': HWPUNIT_PER_INCH,
        'pt': HWPUNIT_PER_PT,
    }

    if unit not in conversions:
        raise ValueError(f"Unknown unit: {unit}. Supported: mm, cm, in, pt")

    result = int(round(number * conversions[unit]))
    return result

    
def from_hwpunit(hwpunit_value: int, target_unit: str = "mm") -> float:
    """
    Convert HWPUNIT to specified unit.

    Args:
        hwpunit_value: Value in HWPUNIT
        target_unit: Desired output unit ("mm", "cm", "in", "pt")

    Returns:
        Value in target unit

    Examples:
        >>> from_hwpunit(59430, "mm")
        210.0
        >>> from_hwpunit(59430, "cm")
        21.0
    """
    
    conversions = {
        'mm': HWPUNIT_PER_MM,
        'cm': HWPUNIT_PER_CM,
        'in': HWPUNIT_PER_INCH,
        'pt': HWPUNIT_PER_PT,
    }

    if target_unit not in conversions:
        raise ValueError(f"Unknown unit: {target_unit}. Supported: mm, cm, in, pt")

    result = round(hwpunit_value / conversions[target_unit], 2)
    return result

# %% ../nbs/02_api/02_functions.ipynb 29
def block_input(func):
    """
    logger.debug(f"block_input called")
    함수가 실행될 동안 다른 입력을 할 수 없게 하는 기능을 가진 데코레이터입니다. 
    """
    logger.debug(f"Calling block_input")
    def wrapper(app, *args, **kwargs):
        logger.debug(f"wrapper called")
        app.api.EditMode = 0
        result = func(app, *args, **kwargs)
        app.api.EditMode = 1
        return result
    return wrapper
