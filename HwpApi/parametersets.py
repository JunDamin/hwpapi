# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_api/02_parameters.ipynb.

# %% ../nbs/02_api/02_parameters.ipynb 4
from __future__ import annotations
from .functions import from_hwpunit, to_hwpunit, convert_hwp_color_to_hex, convert_to_hwp_color
import pprint
from typing import Any, Dict, List, Optional, Union, Callable, Type, Protocol, Literal, Iterable


# %% auto 0
__all__ = ['DIRECTION_MAP', 'CAP_FULL_SIZE_MAP', 'ALIGNMENT_MAP', 'VERT_ALIGN_MAP', 'VERT_REL_TO_MAP', 'HORZ_REL_TO_MAP',
           'HORZ_ALIGN_MAP', 'ALIGN_MAP', 'ALIGN_TYPE_MAP', 'FONTTYPE_MAP', 'TEXT_DIRECTION_MAP', 'TEXT_ALIGN_MAP',
           'LINE_SPACING_TYPE_MAP', 'LINE_WRAP_MAP', 'TEXT_WRAP_MAP', 'TEXT_FLOW_MAP', 'LATIN_LINE_BREAK_MAP',
           'NONLATIN_LINE_BREAK_MAP', 'SHADOW_TYPE_MAP', 'BACKGROUND_TYPE_MAP', 'GRADATION_TYPE_MAP',
           'ROTATION_SETTING_MAP', 'PIC_EFFECT_MAP', 'SEARCH_DIRECTION_MAP', 'BORDER_TEXT_MAP', 'UNDERLINE_TYPE_MAP',
           'OUTLINE_TYPE_MAP', 'STRIKEOUT_TYPE_MAP', 'USE_KERNING_MAP', 'DIAC_SYM_MARK_MAP', 'USE_FONT_SPACE_MAP',
           'HEADING_TYPE_MAP', 'NUMBERING_TYPE_MAP', 'NUMBER_FORMAT_MAP', 'PAGE_BREAK_MAP', 'ALL_MAPPINGS',
           'ParameterBackend', 'ComBackend', 'AttrBackend', 'HParamBackend', 'make_backend', 'to_dict_hparam',
           'snapshot_hparam', 'apply_dict_hparam', 'temp_edit_hparam', 'resolve_action_args', 'apply_staged_to_backend',
           'MissingRequiredError', 'PropertyDescriptor', 'IntProperty', 'BoolProperty', 'StringProperty',
           'ColorProperty', 'UnitProperty', 'MappedProperty', 'TypedProperty', 'ListProperty', 'ParameterSetMeta',
           'ParameterSet', 'BorderFill', 'Caption', 'FindReplace', 'DrawFillAttr', 'CharShape', 'ParaShape',
           'ShapeObject', 'Table', 'BulletShape', 'Cell', 'CtrlData', 'DrawArcType', 'DrawCoordInfo',
           'DrawCtrlHyperlink', 'DrawEditDetail', 'DrawImageAttr', 'DrawImageScissoring', 'DrawLayout', 'DrawLineAttr',
           'DrawRectType', 'DrawResize', 'DrawRotate', 'DrawScAction', 'DrawShadow', 'DrawShear', 'DrawTextart',
           'ListProperties', 'NumberingShape', 'TabDef']

# %% ../nbs/02_api/02_parameters.ipynb 6
# Direction mappings
DIRECTION_MAP = {"left": 0, "right": 1, "top": 2, "bottom": 3}

# Size and alignment mappings
CAP_FULL_SIZE_MAP = {"exclude": 0, "include": 1}
ALIGNMENT_MAP = {"left": 0, "center": 1, "right": 2}
VERT_ALIGN_MAP = {"top": 0, "center": 1, "bottom": 2}
VERT_REL_TO_MAP = {"paper": 0, "page": 1, "paragraph": 2}
HORZ_REL_TO_MAP = {"paper": 0, "page": 1, "column": 2, "paragraph": 3}
HORZ_ALIGN_MAP = {"left": 0, "center": 1, "right": 2, "inside": 3, "outside": 4}
ALIGN_MAP = {"left": 0, "center": 1, "right": 2}
ALIGN_TYPE_MAP = {"between": 0, "left": 1, "right": 2, "center": 3, "ratio": 4, "shared": 5}

# Font and text mappings
FONTTYPE_MAP = {"don't care": 0, "TTF": 1, "HFT": 2, "dontcare": 0, "ttf": 1, "htf": 2}
TEXT_DIRECTION_MAP = {"horizontal": 0, "vertical": 1}
TEXT_ALIGN_MAP = {"font": 0, "up": 1, "middle": 2, "down": 3}
LINE_SPACING_TYPE_MAP = {"font": 0, "fixed": 1, "space": 2}

# Line and text wrapping mappings
LINE_WRAP_MAP = {"basic": 0, "no_newline": 1, "forced": 2}
TEXT_WRAP_MAP = {"square": 0, "top_bottom": 1, "behind": 2, "front": 3, "tight": 4, "through": 5}
TEXT_FLOW_MAP = {"both": 0, "left": 1, "right": 2, "largest": 3}
LATIN_LINE_BREAK_MAP = {"word": 0, "hyphen": 1, "letter": 2}
NONLATIN_LINE_BREAK_MAP = {"word": 0, "letter": 1}

# Style and effect mappings
SHADOW_TYPE_MAP = {"none": 0, "drop": 1, "continuous": 2}
BACKGROUND_TYPE_MAP = {"empty": 0, "fill": 1, "picture": 2, "gradation": 3}
GRADATION_TYPE_MAP = {"stripe": 1, "circle": 2, "cone": 3, "square": 4}
ROTATION_SETTING_MAP = {"none": 0, "setted_rotation": 1, "picture_centered_rotation": 2, "rotation_and_centered": 3}
PIC_EFFECT_MAP = {"none": 0, "bw": 1, "sepia": 2}

# Search and direction mappings
SEARCH_DIRECTION_MAP = {"down": 0, "up": 1, "doc": 2}

# Border and outline mappings
BORDER_TEXT_MAP = {"column": 0, "text": 1}
UNDERLINE_TYPE_MAP = {"none": 0, "bottom": 1, "center": 2, "top": 3}
OUTLINE_TYPE_MAP = {
    "none": 0, "solid": 1, "dot": 2, "thick": 3,
    "dash": 4, "dashdot": 5, "dashdotdot": 6,
}
STRIKEOUT_TYPE_MAP = {
    "none": 0, "red single": 1, "red double": 2,
    "text single": 3, "text double": 4,
}

# Special character and formatting mappings
USE_KERNING_MAP = {"off": 0, "on": 1}
DIAC_SYM_MARK_MAP = {"none": 0, "black circle": 1, "empty circle": 2}
USE_FONT_SPACE_MAP = {"off": 0, "on": 1}
HEADING_TYPE_MAP = {"none": 0, "outline": 1, "number": 2, "bullet": 3}

# Numbering and formatting mappings
NUMBERING_TYPE_MAP = {"none": 0, "picture": 1, "table": 2, "equation": 3}
NUMBER_FORMAT_MAP = {
    "1": 0, "circled 1": 1, "I": 2, "i": 3, "A": 4, "a": 5,
    "circled A": 6, "circled a": 7, "가": 8, "동그라미 가": 9,
    "ㄱ": 10, "동그라미 ㄱ": 11, "일": 12, "一": 13, "동그라미 一": 14
}

# Page and table mappings
PAGE_BREAK_MAP = {"none": 0, "cell": 1, "text": 2}

# All mappings registry for easy access
ALL_MAPPINGS = {
    "direction": DIRECTION_MAP,
    "cap_full_size": CAP_FULL_SIZE_MAP,
    "alignment": ALIGNMENT_MAP,
    "fonttype": FONTTYPE_MAP,
    "shadow_type": SHADOW_TYPE_MAP,
    "background_type": BACKGROUND_TYPE_MAP,
    "gradation_type": GRADATION_TYPE_MAP,
    "rotation_setting": ROTATION_SETTING_MAP,
    "search_direction": SEARCH_DIRECTION_MAP,
    "text_direction": TEXT_DIRECTION_MAP,
    "line_wrap": LINE_WRAP_MAP,
    "text_wrap": TEXT_WRAP_MAP,
    "text_flow": TEXT_FLOW_MAP,
    "vert_align": VERT_ALIGN_MAP,
    "vert_rel_to": VERT_REL_TO_MAP,
    "horz_rel_to": HORZ_REL_TO_MAP,
    "horz_align": HORZ_ALIGN_MAP,
    "align": ALIGN_MAP,
    "align_type": ALIGN_TYPE_MAP,
    "latin_line_break": LATIN_LINE_BREAK_MAP,
    "nonlatin_line_break": NONLATIN_LINE_BREAK_MAP,
    "text_align": TEXT_ALIGN_MAP,
    "heading_type": HEADING_TYPE_MAP,
    "border_text": BORDER_TEXT_MAP,
    "underline_type": UNDERLINE_TYPE_MAP,
    "outline_type": OUTLINE_TYPE_MAP,
    "strikeout_type": STRIKEOUT_TYPE_MAP,
    "use_kerning": USE_KERNING_MAP,
    "diac_sym_mark": DIAC_SYM_MARK_MAP,
    "use_font_space": USE_FONT_SPACE_MAP,
    "numbering_type": NUMBERING_TYPE_MAP,
    "number_format": NUMBER_FORMAT_MAP,
    "line_spacing_type": LINE_SPACING_TYPE_MAP,
    "pic_effect": PIC_EFFECT_MAP,
    "page_break": PAGE_BREAK_MAP,
}


# %% ../nbs/02_api/02_parameters.ipynb 8
# ===================
# Backends (COM vs. Python)  
# =========================

class ParameterBackend(Protocol):
    """Protocol for parameter backends."""
    def get(self, key: str) -> Any: ...
    def set(self, key: str, value: Any) -> None: ...
    def delete(self, key: str) -> bool: ...


class ComBackend:
    """win32com-style backend using Item/SetItem/RemoveItem."""
    def __init__(self, obj: Any):
        self._obj = obj

    def get(self, key: str) -> Any:
        return self._obj.Item(key)

    def set(self, key: str, value: Any) -> None:
        self._obj.SetItem(key, value)

    def delete(self, key: str) -> bool:
        try:
            self._obj.RemoveItem(key)
            return True
        except Exception:
            return False


class AttrBackend:
    """
    Fallback for plain Python objects:
    - attribute access if hasattr
    - dict-like access otherwise
    """
    def __init__(self, obj: Any):
        self._obj = obj

    def get(self, key: str) -> Any:
        if hasattr(self._obj, key):
            return getattr(self._obj, key)
        if isinstance(self._obj, dict):
            return self._obj.get(key, None)
        return self._obj[key]

    def set(self, key: str, value: Any) -> None:
        if hasattr(self._obj, key):
            setattr(self._obj, key, value)
        elif isinstance(self._obj, dict):
            self._obj[key] = value
        else:
            self._obj[key] = value

    def delete(self, key: str) -> bool:
        if hasattr(self._obj, key):
            try:
                delattr(self._obj, key)
                return True
            except Exception:
                return False
        if isinstance(self._obj, dict):
            return self._obj.pop(key, None) is not None
        try:
            del self._obj[key]
            return True
        except Exception:
            return False



# %% ../nbs/02_api/02_parameters.ipynb 9
# ===================
# HParam Utilities (for HParameterSet support)
# ===================
# HParam utilities for tree access and VT coercion

def _is_com(obj) -> bool:
    """Check if object is a COM object."""
    return hasattr(obj, '_oleobj_') or str(type(obj)).find('com_gen_py') != -1

def _prop_map_get(obj) -> dict:
    """Get property map for reading COM object properties."""
    return getattr(obj, '_prop_map_get_', {})

def _prop_map_put(obj) -> dict:
    """Get property map for writing COM object properties."""
    return getattr(obj, '_prop_map_put_', {})

def _split_dotted(key: str) -> list[str]:
    """Split dotted key like 'HFindReplace.FindString' into ['HFindReplace', 'FindString']."""
    return key.split('.')

def _resolve_parent_and_leaf(root, dotted: str) -> tuple[Any, str]:
    """
    Resolve dotted path to (parent_object, leaf_name).
    E.g., 'HFindReplace.FindString' -> (root.HFindReplace, 'FindString')
    """
    parts = _split_dotted(dotted)
    if len(parts) == 1:
        return root, parts[0]
    
    current = root
    for part in parts[:-1]:
        if not hasattr(current, part):
            raise KeyError(f"Path '{dotted}' not found: missing '{part}' in {type(current)}")
        current = getattr(current, part)
    
    return current, parts[-1]

def _coerce_for_put(parent, prop, value) -> Any:
    """
    Coerce value for COM property using VT codes when available.
    Uses _prop_map_put_ VT codes for type conversion.
    """
    prop_map = _prop_map_put(parent)
    if prop in prop_map:
        vt_info = prop_map[prop]
        # VT_I4=3, VT_BOOL=11, VT_BSTR=8, VT_R8=5, etc.
        if isinstance(vt_info, tuple) and len(vt_info) > 1:
            vt_code = vt_info[1]  # Usually (flags, vt_code)
        elif isinstance(vt_info, int):
            vt_code = vt_info
        else:
            return value  # Can't determine VT, pass through
            
        # Basic VT coercion
        if vt_code == 11:  # VT_BOOL
            return bool(value)
        elif vt_code in (2, 3, 22):  # VT_I2, VT_I4, VT_UI4
            return int(value)
        elif vt_code in (4, 5):  # VT_R4, VT_R8
            return float(value)
        elif vt_code == 8:  # VT_BSTR
            return str(value)
    
    return value  # Default: pass through unchanged



def _looks_like_hparamset(obj: Any) -> bool:
    """
    Check if object appears to be an HParameterSet:
    - Has .HSet attribute, OR
    - Is a COM object with child nodes that look like HParam nodes
    """
    if hasattr(obj, 'HSet'):
        return True
    
    if not _is_com(obj):
        return False
    
    # Check for common HParam child nodes
    common_hparam_nodes = ['HFindReplace', 'HCharShape', 'HParaShape', 'HTable', 'HBorderFill']
    for node in common_hparam_nodes:
        if hasattr(obj, node):
            return True
    
    return False


class HParamBackend:
    """
    Backend for HParameterSet (tree-structured, shared state).
    Supports dotted keys like 'HFindReplace.FindString', 'HCharShape.Bold'.
    Uses _prop_map_put_ for type-aware coercion when available.
    """
    
    def __init__(self, root: Any):
        """Initialize with root HParameterSet or any child node."""
        self._root = root

    def get(self, key: str) -> Any:
        """Get value using dotted key path."""
        try:
            parent, leaf = _resolve_parent_and_leaf(self._root, key)
            return getattr(parent, leaf)
        except (AttributeError, KeyError) as e:
            raise KeyError(f"Cannot get '{key}': {e}") from e

    def set(self, key: str, value: Any) -> None:
        """Set value using dotted key path with type-aware coercion."""
        try:
            parent, leaf = _resolve_parent_and_leaf(self._root, key)
            coerced_value = _coerce_for_put(parent, leaf, value)
            setattr(parent, leaf, coerced_value)
        except (AttributeError, KeyError) as e:
            raise KeyError(f"Cannot set '{key}': {e}") from e
        except TypeError as e:
            # Re-raise with dotted path context
            raise TypeError(f"Cannot set '{key}': {e}") from e

    def delete(self, key: str) -> bool:
        """
        Best-effort neutralization (not true deletion).
        Sets property to neutral value: 0/False/"" based on current type.
        
        Note: This is neutralization, not true deletion, due to HParameterSet's
        shared/global nature.
        """
        try:
            parent, leaf = _resolve_parent_and_leaf(self._root, key)
            current = getattr(parent, leaf)
            
            # Determine neutral value based on current type
            if isinstance(current, bool):
                neutral = False
            elif isinstance(current, (int, float)):
                neutral = 0
            elif isinstance(current, str):
                neutral = ""
            else:
                neutral = None
            
            if neutral is not None:
                setattr(parent, leaf, neutral)
                return True
            return False
        except Exception:
            return False


def make_backend(obj: Any) -> ParameterBackend:
    """
    Auto-detect backend type:
    - ParameterSet: has SetID or all of Item/SetItem/RemoveItem → ComBackend
    - HParameterSet: COM object with .HSet or HParam child nodes → HParamBackend  
    - Else → AttrBackend
    """
    # Check for classic ParameterSet first
    if hasattr(obj, "SetID") or all(hasattr(obj, n) for n in ("Item", "SetItem", "RemoveItem")):
        return ComBackend(obj)
    
    # Check for HParameterSet
    if _looks_like_hparamset(obj):
        return HParamBackend(obj)
    
    # Fallback to attribute/dict backend
    return AttrBackend(obj)




# %% ../nbs/02_api/02_parameters.ipynb 10
# ===================
# Non-destructive HParam helpers
# ===================

def to_dict_hparam(root: Any, base: str, depth: int = 4) -> dict:
    """
    Convert HParameterSet node to nested dict of primitives.
    Avoids COM dumps/callables by only including basic types.
    
    Args:
        root: HParameterSet root object
        base: Base path like "HFindReplace" or "HCharShape"  
        depth: Maximum recursion depth to prevent infinite loops
    
    Returns:
        Nested dict with primitive values only
    """
    if depth <= 0:
        return {}
    
    try:
        parent, leaf = _resolve_parent_and_leaf(root, base)
        node = getattr(parent, leaf)
    except (KeyError, AttributeError):
        return {}
    
    result = {}
    
    # Get all attributes that look like properties (not methods/internals)
    for attr_name in dir(node):
        if attr_name.startswith('_') or attr_name.startswith('__'):
            continue
            
        try:
            attr_value = getattr(node, attr_name)
            
            # Only include primitive types or recursively handle COM objects
            if isinstance(attr_value, (int, float, bool, str)):
                result[attr_name] = attr_value
            elif _is_com(attr_value) and depth > 1:
                # Recursively handle nested COM objects
                nested = to_dict_hparam(root, f"{base}.{attr_name}", depth - 1)
                if nested:
                    result[attr_name] = nested
        except Exception:
            # Skip properties that can't be read
            continue
    
    return result


def snapshot_hparam(root: Any, base: str) -> dict:
    """
    Create a snapshot of HParameterSet node as a flat dict with dotted keys.
    
    Args:
        root: HParameterSet root object
        base: Base path like "HFindReplace"
        
    Returns:
        Flat dict like {"FindString": "text", "IgnoreCase": True}
    """
    nested_dict = to_dict_hparam(root, base, depth=2)
    
    def flatten_dict(d: dict, prefix: str = "") -> dict:
        result = {}
        for key, value in d.items():
            new_key = f"{prefix}.{key}" if prefix else key
            if isinstance(value, dict):
                result.update(flatten_dict(value, new_key))
            else:
                result[new_key] = value
        return result
    
    return flatten_dict(nested_dict)


def apply_dict_hparam(root: Any, base: str, data: dict, strict: bool = True) -> None:
    """
    Apply flat dict with dotted keys to HParameterSet node.
    
    Args:
        root: HParameterSet root object  
        base: Base path like "HFindReplace"
        data: Flat dict like {"FindString": "text", "IgnoreCase": True}
        strict: If True, raise on missing properties; if False, skip silently
    """
    backend = HParamBackend(root)
    
    for key, value in data.items():
        full_key = f"{base}.{key}" if not key.startswith(base) else key
        try:
            backend.set(full_key, value)
        except (KeyError, TypeError) as e:
            if strict:
                raise
            # Silently skip if not strict


def temp_edit_hparam(root: Any, base: str, changes: dict):
    """
    Context manager for non-destructive editing of HParameterSet.
    Snapshots current state, applies changes, then restores on exit.
    
    Args:
        root: HParameterSet root object
        base: Base path like "HFindReplace"  
        changes: Dict of changes to apply
        
    Usage:
        with temp_edit_hparam(app.api.HParameterSet, "HFindReplace", {"FindString": "test"}):
            # HFindReplace.FindString is temporarily "test"
            app.HAction.Execute("FindReplace", app.api.HParameterSet.HFindReplace)
        # HFindReplace.FindString is restored to original value
    """
    return _TempEditHParam(root, base, changes)


class _TempEditHParam:
    """Context manager implementation for temp_edit_hparam."""
    
    def __init__(self, root: Any, base: str, changes: dict):
        self.root = root
        self.base = base
        self.changes = changes
        self.snapshot = {}
        
    def __enter__(self):
        # Take snapshot of current values
        self.snapshot = snapshot_hparam(self.root, self.base)
        
        # Apply changes
        apply_dict_hparam(self.root, self.base, self.changes, strict=False)
        
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        # Restore original values
        try:
            apply_dict_hparam(self.root, self.base, self.snapshot, strict=False)
        except Exception:
            # Best effort restore - don't mask original exceptions
            pass


def resolve_action_args(app: Any, action_name: str, hnode: Any) -> tuple[str, Any]:
    """
    Resolve action arguments for HAction.GetDefault/Execute calls.
    
    Args:
        app: HWP application object
        action_name: Action name like "FindReplace"
        hnode: HParameterSet node like app.api.HParameterSet.HFindReplace
        
    Returns:
        Tuple of (action_name, arg) where arg is hnode.HSet if available, else hnode
    """
    # Try to use .HSet if available (preferred for some actions)
    if hasattr(hnode, 'HSet'):
        return (action_name, hnode.HSet)
    else:
        return (action_name, hnode)


def apply_staged_to_backend(backend: ParameterBackend, staged: dict, prefix: str = "") -> None:
    """
    Apply staged changes to any backend type, handling dotted keys recursively.
    Works for both ComBackend (map-style) and HParamBackend (tree-style).
    
    Args:
        backend: Any ParameterBackend implementation
        staged: Dict of staged changes (may contain nested dicts)
        prefix: Key prefix for recursion (internal use)
    """
    for key, value in staged.items():
        full_key = f"{prefix}.{key}" if prefix else key
        
        if isinstance(value, dict):
            # Recursively handle nested dicts
            apply_staged_to_backend(backend, value, full_key)
        elif isinstance(value, ParameterSet):
            # Handle nested ParameterSet - apply its staged changes
            if hasattr(value, '_staged') and value._staged:
                apply_staged_to_backend(backend, value._staged, full_key)
        else:
            # Apply primitive value
            try:
                backend.set(full_key, value)
            except Exception as e:
                # Re-raise with context
                raise RuntimeError(f"Failed to apply staged value '{full_key}': {e}") from e

class MissingRequiredError(ValueError):
    """Raised when required parameters are missing during apply()."""
    pass


class PropertyDescriptor:
    """
    Descriptor for parameter properties backed by a staged ParameterSet.

    Features:
    - Reads prefer staged values, then snapshot, then default.
    - Writes stage the value; nothing is sent until ParameterSet.apply().
    - Optional automatic wrapping of nested ParameterSets via `wrap=...`.
    """
    def __init__(
        self,
        key: str,
        doc: str = "",
        *,
        to_python: Optional[Callable[[Any], Any]] = None,
        to_backend: Optional[Callable[[Any], Any]] = None,
        default: Any = None,
        readonly: bool = False,
        required: bool = False,
        wrap: Optional[Type["ParameterSet"]] = None,  # <-- NEW: nested ParameterSet subclass
    ):
        self.key = key
        self.doc = doc
        self.name: Optional[str] = None
        self.to_python = to_python
        self.to_backend = to_backend
        self.default = default
        self.readonly = readonly
        self.required = required
        self.wrap = wrap

    def __set_name__(self, owner, name):
        self.name = name
        reg = getattr(owner, "_property_registry", None)
        if reg is None:
            reg = {}
            setattr(owner, "_property_registry", reg)
        reg[name] = self

    def __get__(self, instance: Optional["ParameterSet"], owner):
        if instance is None:
            return self

        # Get staged/snapshot value
        val = instance._ps_get(self)

        # Automatic wrapping for nested ParameterSets
        if self.wrap is not None:
            # Serve from cache if we already wrapped this key
            cached = instance._wrapper_cache.get(self.key)
            if cached is not None:
                return cached

            # If staged/snapshot holds an existing ParameterSet, cache and return it
            if isinstance(val, ParameterSet):
                instance._wrapper_cache[self.key] = val
                return val

            # If backend returned a raw nested object (COM or dict-like), wrap it now
            if val is not None:
                # Handle both lambda functions (like lambda: CharShape) and direct class references
                if callable(self.wrap):
                    try:
                        # Try calling with no arguments first (for lambda: ClassName patterns)
                        wrapper_class = self.wrap()
                        wrapped = wrapper_class(val) if val != {} else wrapper_class()
                    except TypeError:
                        # If that fails, try calling with val as argument (for direct callable patterns)
                        wrapped = self.wrap(val)
                else:
                    # Direct class reference
                    wrapped = self.wrap(val) if val != {} else self.wrap()
   
                instance._wrapper_cache[self.key] = wrapped
                # Also stage the wrapper so reads stay consistent
                instance._staged[self.key] = wrapped
                return wrapped

            # If value is None, fall through to default handling below

        # Non-wrapped (or None) path
        if val is None and self.default is not None:
            return self.default
        return self.to_python(val) if (val is not None and self.to_python) else val

    def __set__(self, instance: "ParameterSet", value: Any):
        if self.readonly:
            raise AttributeError(f"'{self.name}' is read-only")

        # If this property is a nested ParameterSet, normalize on assignment:
        if self.wrap is not None:
            # Allow passing: ParameterSet, raw COM object, or dict-like
            if isinstance(value, ParameterSet):
                wrapped = value
            else:
                # If dict/raw object given, create a wrapper
                wrapped = self.wrap(value if value is not None else {})
            # Keep cache consistent so subsequent gets reuse same object
            instance._wrapper_cache[self.key] = wrapped
            # Stage the wrapper (not the raw) — parent apply() will unwrap
            instance._ps_set(self, wrapped)
            return

        # Primitive path: run to_backend if provided
        v = self.to_backend(value) if (value is not None and self.to_backend) else value
        instance._ps_set(self, v)

    def _get_value(self, instance):
        return instance._ps_get(self)
    def _set_value(self, instance, value):
        instance._ps_set(self, value)
    def _del_value(self, instance): return instance._ps_del(self)



# %% ../nbs/02_api/02_parameters.ipynb 11
class IntProperty(PropertyDescriptor):
    """Property descriptor for integer values with optional range validation."""
    
    def __init__(self, key: str, doc: str, min_val: Optional[int] = None, max_val: Optional[int] = None):
        super().__init__(key, doc)
        self.min_val = min_val
        self.max_val = max_val
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self._get_value(instance)
        return int(value) if value is not None else None
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        if not isinstance(value, (int, float)):
            raise TypeError(f"Value for '{self.key}' must be numeric")
        
        value = int(value)
        
        if self.min_val is not None and value < self.min_val:
            raise ValueError(f"Value {value} for '{self.key}' is below minimum {self.min_val}")
        if self.max_val is not None and value > self.max_val:
            raise ValueError(f"Value {value} for '{self.key}' is above maximum {self.max_val}")
        
        return self._set_value(instance, value)


# %% ../nbs/02_api/02_parameters.ipynb 12
class BoolProperty(PropertyDescriptor):
    """Property descriptor for boolean values (0 or 1)."""
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self._get_value(instance)
        return bool(value) if value is not None else None
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        if isinstance(value, bool):
            numeric_value = 1 if value else 0
        elif isinstance(value, (int, float)):
            numeric_value = 1 if value else 0
        else:
            raise TypeError(f"Value for '{self.key}' must be boolean or numeric")
        
        return self._set_value(instance, numeric_value)


# %% ../nbs/02_api/02_parameters.ipynb 13
class StringProperty(PropertyDescriptor):
    """Property descriptor for string values."""
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self._get_value(instance)
        return str(value) if value is not None else None
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        if not isinstance(value, str):
            value = str(value)
        
        return self._set_value(instance, value)


# %% ../nbs/02_api/02_parameters.ipynb 14
class ColorProperty(PropertyDescriptor):
    """Property descriptor for color values with hex conversion."""
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self._get_value(instance)
        return convert_hwp_color_to_hex(value) if value is not None else None
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        numeric_value = convert_to_hwp_color(value)
        return self._set_value(instance, numeric_value)


# %% ../nbs/02_api/02_parameters.ipynb 15
class UnitProperty(PropertyDescriptor):
    """Property descriptor for unit-based values with automatic conversion."""
    
    def __init__(self, key: str, unit: str, doc: str):
        super().__init__(key, doc)
        self.unit = unit
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self._get_value(instance)
        if value is None:
            return None
        return from_hwpunit(value, self.unit)
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        if not isinstance(value, (int, float)):
            raise TypeError(f"Value for '{self.key}' must be numeric")
        
        hwp_value = to_hwpunit(value, self.unit)
        return self._set_value(instance, hwp_value)


# %% ../nbs/02_api/02_parameters.ipynb 16
class MappedProperty(PropertyDescriptor):
    """Property descriptor for mapped values (string <-> integer)."""
    
    def __init__(self, key: str, mapping: Dict[str, int], doc: str):
        super().__init__(key, doc)
        self.mapping = mapping
        self.reverse_mapping = {v: k for k, v in mapping.items()}
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self._get_value(instance)
        if value is None:
            return None
        return self.reverse_mapping.get(value, value)
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        if isinstance(value, str):
            if value not in self.mapping:
                valid_keys = list(self.mapping.keys())
                raise ValueError(f"Invalid value '{value}' for '{self.key}'. Valid options: {valid_keys}")
            numeric_value = self.mapping[value]
        elif isinstance(value, (int, float)):
            numeric_value = int(value)
            if numeric_value not in self.reverse_mapping:
                valid_values = list(self.reverse_mapping.keys())
                raise ValueError(f"Invalid numeric value '{numeric_value}' for '{self.key}'. Valid values: {valid_values}")
        else:
            raise TypeError(f"Value for '{self.key}' must be string or numeric")
        
        return self._set_value(instance, numeric_value)


# %% ../nbs/02_api/02_parameters.ipynb 17
class TypedProperty(PropertyDescriptor):
    """Property descriptor for typed parameter sets - DEPRECATED: Use wrap= parameter instead."""
    
    def __init__(self, key: str, doc: str, expected_type: Callable):
        # Convert to new wrap-based approach
        super().__init__(key, doc, wrap=expected_type)

# %% ../nbs/02_api/02_parameters.ipynb 18
class ListProperty(PropertyDescriptor):
    """Property descriptor for list values."""
    
    def __init__(self, key: str, doc: str, item_type: Optional[Type] = None, 
                 min_length: Optional[int] = None, max_length: Optional[int] = None):
        super().__init__(key, doc)
        self.item_type = item_type
        self.min_length = min_length
        self.max_length = max_length
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self._get_value(instance)
        return list(value) if value is not None else None
    
    def __set__(self, instance, value):
        if value is None:
            return self._del_value(instance)
        
        if not isinstance(value, (list, tuple)):
            raise TypeError(f"Value for '{self.key}' must be a list or tuple")
        
        value = list(value)
        
        # Length validation
        if self.min_length is not None and len(value) < self.min_length:
            raise ValueError(f"List for '{self.key}' must have at least {self.min_length} items")
        if self.max_length is not None and len(value) > self.max_length:
            raise ValueError(f"List for '{self.key}' must have at most {self.max_length} items")
        
        # Type validation
        if self.item_type is not None:
            for i, item in enumerate(value):
                if not isinstance(item, self.item_type):
                    if self.item_type == tuple and isinstance(item, (list, tuple)) and len(item) == 2:
                        value[i] = tuple(item)
                    else:
                        try:
                            value[i] = self.item_type(item)
                        except (ValueError, TypeError):
                            raise TypeError(f"Item {i} in list for '{self.key}' must be of type {self.item_type.__name__}")
        
        return self._set_value(instance, value)


# %% ../nbs/02_api/02_parameters.ipynb 20
class ParameterSetMeta(type):
    """Metaclass for automatic property registration."""
    
    def __new__(cls, name, bases, namespace):
        # Collect property descriptors
        properties = {}
        for key, value in namespace.items():
            if isinstance(value, PropertyDescriptor):
                properties[key] = value
        
        # Store property registry
        namespace['_property_registry'] = properties
        
        # Create the class
        new_class = super().__new__(cls, name, bases, namespace)
        
        # Collect all properties from base classes too
        all_properties = {}
        for base in reversed(new_class.__mro__):
            if hasattr(base, '_property_registry'):
                all_properties.update(base._property_registry)
        
        new_class._all_properties = all_properties
        
        return new_class


# %% ../nbs/02_api/02_parameters.ipynb 21
class ParameterSet(metaclass=ParameterSetMeta):
    """
    Staged parameter set with flexible value entry and nested wrapping:
      - Accept initial values at construction (staged).
      - Accept overrides when calling apply().
      - Validate required fields at apply-time (configurable).
      - Reads: staged -> snapshot -> default.
      - Nested sets: descriptors with wrap=... auto-wrap raw COM/dict values; apply() cascades.

    New behavior:
      - `parameterset` is optional at __init__; required at apply-time.
      - Validate the bound parameterset by checking `.SetID`, optionally against REQUIRED_SETID/expected_setid.
    """

    # Optional class-level expected SetID. Subclasses can override.
    REQUIRED_SETID: Optional[str] = None

    _property_registry: Dict[str, PropertyDescriptor]  # populated by descriptors

    def __init__(
        self,
        parameterset: Any = None,                 # <-- now optional
        *,
        backend_factory: Optional[Callable[[Any], ParameterBackend]] = None,
        initial: Optional[Dict[str, Any]] = None,
        expected_setid: Optional[str] = None,     # <-- new
        app_instance: Any = None,                 # <-- new: reference to App instance
        **kwargs,
    ):
        if backend_factory is None:
            backend_factory = make_backend

        # Expected SetID (instance preference > class default)
        self._expected_setid: Optional[str] = expected_setid if expected_setid is not None else getattr(self.__class__, "REQUIRED_SETID", None)

        # Store App instance reference for HSet synchronization
        self._app_instance: Any = app_instance

        # Placeholders before binding
        self._raw: Any = None
        self._backend: Optional[ParameterBackend] = None
        self._pset: Any = None
        self._is_pset: bool = False
        self.attributes_names = []

        # A stable snapshot of current remote values (keyed by descriptor.key)
        self._snapshot: Dict[str, Any] = {}
        # Staged changes (key -> value) not yet applied
        self._staged: Dict[str, Any] = {}
        # Keys marked for deletion
        self._deleted: set[str] = set()
        # Cache of wrapped nested ParameterSets keyed by raw parameter key
        self._wrapper_cache: Dict[str, ParameterSet] = {}

        # Bind immediately if provided, otherwise start unbound
        if parameterset is not None:
            self.bind(parameterset, backend_factory=backend_factory)
        else:
            # start empty; snapshot stays empty until bind+reload
            pass

        # Stage initial values (do NOT send yet)
        if initial:
            self.update(initial)
        if kwargs:
            self.update(kwargs)

    def bind(self, parameterset: Any, *, backend_factory: Optional[Callable[[Any], ParameterBackend]] = None):
        """
        Bind/attach a raw parameterset to this instance (or re-bind a new one).
        Validates SetID presence and (optionally) equality to expected SetID.
        """
        if parameterset is None:
            raise TypeError("bind(): 'parameterset' must not be None")

        # Must expose SetID
        if not hasattr(parameterset, "SetID") and (self._expected_setid is not None and self._expected_setid not in str(parameterset.__class__)):
            raise TypeError("bind(): provided object has no 'SetID' attribute")

        # If we know what to expect, enforce it
        if self._expected_setid is not None and ((self._expected_setid not in str(parameterset.__class__)) or (getattr(parameterset, "SetID", None) != self._expected_setid)):
            raise ValueError(
                f"bind(): parameterset.SetID={getattr(parameterset,'SetID',None)!r} "
                f"does not match expected {self._expected_setid!r}"
            )

        if backend_factory is None:
            backend_factory = make_backend

        # Commit the binding
        self._raw = parameterset
        self._backend = backend_factory(parameterset)
        self._pset = parameterset
        self._is_pset = True

        # Refresh snapshot from the newly bound backend
        self.reload()
        return self

    @property
    def parameterset(self):
        """Return the underlying raw object (COM ParameterSet or Python object), or None if unbound."""
        self.apply()
        return self._raw

    def reload(self):
        """Refresh in-memory snapshot from backend and clear staged edits (but keep wrapper cache coherent)."""
        self._snapshot.clear()

        # If not yet bound, nothing to load; keep staged/deleted but clean them for safety.
        if self._backend is None:
            self._staged.clear()
            self._deleted.clear()
            return self

        for name, desc in self._property_registry.items():
            try:
                self._snapshot[desc.key] = self._backend.get(desc.key)
            except Exception:
                self._snapshot[desc.key] = None
        self._staged.clear()
        self._deleted.clear()
        return self

    def apply(
        self,
        overrides: Optional[Dict[str, Any]] = None,
        *,
        require: Literal["error", "warn", "skip"] = "error",
        only_overrides: bool = False,
        parameterset: Any = None,                 # <-- NEW: allow binding at apply-time
        **kwargs,
    ):
        """
        Flush staged changes (and deletions) to backend.

        Parameters
        ----------
        overrides : dict | None
            Additional values (by attribute name) to stage just-in-time.
        require : {"error","warn","skip"}
            Control missing-required behavior at apply-time.
        only_overrides : bool
            If True, ignore previously staged edits and apply ONLY overrides/**kwargs.
        parameterset : Any | None
            Optionally (re)bind a raw parameterset right before applying. Required if not already bound.
        **kwargs
            Same as overrides; convenient for inline use.
        """
        # Ensure we are bound; if not, we must bind now and validate SetID
        if self._backend is None:
            if parameterset is None:
                raise RuntimeError(
                    "apply(): no parameterset is bound. Pass 'parameterset=' or call .bind() first."
                )
            self.bind(parameterset)

        # Optionally ignore prior staged changes
        saved_staged = None
        saved_deleted = None
        if only_overrides:
            saved_staged = self._staged
            saved_deleted = self._deleted
            self._staged = {}
            self._deleted = set()

        # Add incoming values to staged
        if overrides:
            self.update(overrides)
        if kwargs:
            self.update(kwargs)

        # Validate requireds
        if require != "skip":
            missing = self._missing_required()
            if missing:
                msg = f"Missing required parameters: {', '.join(missing)}"
                if require == "error":
                    if only_overrides:
                        self._staged = saved_staged or {}
                        self._deleted = saved_deleted or set()
                    raise MissingRequiredError(msg)
                else:
                    print("[ParameterSet] WARN:", msg)

        # Deletes first
        for key in list(self._deleted):
            try:
                self._backend.delete(key)
            finally:
                self._snapshot[key] = None
        self._deleted.clear()

        # Writes next (cascade to nested ParameterSets and unwrap)
        for key, value in list(self._staged.items()):
            if isinstance(value, ParameterSet):
                # Ensure nested staged values are flushed first
                value.apply(require=require)
                raw_value = value.parameterset
            else:
                raw_value = value
            self._backend.set(key, raw_value)
            self._snapshot[key] = raw_value
        self._staged.clear()

        # Restore pre-existing staged edits if only_overrides=True
        if only_overrides:
            for k, v in (saved_staged or {}).items():
                if k not in self._snapshot or self._snapshot[k] != v:
                    self._staged[k] = v

        # Special handling for HSet-based parameter sets (e.g., FindReplace, FindDlg, FindAll)
        # These actions use global HParameterSet state instead of local parameter sets
        self._sync_hset_global_state()

        return self

    def discard(self):
        """Drop staged edits and deletions (keep snapshot)."""
        self._staged.clear()
        self._deleted.clear()
        return self

    def _sync_hset_global_state(self):
        """
        Synchronize staged changes with global HParameterSet state for HSet-based actions.
        
        The core issue: HSet-based actions use the GLOBAL HParameterSet state, but the 
        simplified API creates LOCAL copies via HAction.GetDefault(). This method bridges
        that gap by copying values from the local parameter set to the global state.
        """
        # Only apply to HParamBackend instances bound to HParameterSet objects
        if not (self._raw is not None and isinstance(self._backend, HParamBackend)):
            return
        
        # We need to find the global HParameterSet - it should be accessible via the backend root
        # or we need to find the App instance somehow
        try:
            # Try to find the App instance by walking up the object hierarchy
            global_hparam = self._find_global_hparameterset()
            if global_hparam is None:
                return
                
            # Auto-detect the HParam node type and sync accordingly
            sync_mappings = {
                'HFindReplace': ('HFindReplace', self._sync_find_replace_to_global),
                'HCharShape': ('HCharShape', self._sync_char_shape_to_global),
                'HParaShape': ('HParaShape', self._sync_para_shape_to_global),
            }
            
            for local_node_name, (global_node_name, sync_method) in sync_mappings.items():
                if hasattr(self._raw, local_node_name) and hasattr(global_hparam, global_node_name):
                    local_node = getattr(self._raw, local_node_name)
                    global_node = getattr(global_hparam, global_node_name)
                    sync_method(local_node, global_node)
                    break
                    
        except Exception as e:
            # Log the error but don't fail the apply operation
            import logging
            logging.warning(f"ParameterSet: Failed to sync with global HParameterSet: {e}")

    def _find_global_hparameterset(self):
        """
        Find the global HParameterSet instance.
        
        The local HParameterSet (self._raw) is created by HAction.GetDefault(),
        but we need to find the global one that actions actually use.
        """
        # Strategy 1: Use the stored App instance reference if available
        if self._app_instance and hasattr(self._app_instance, 'api') and hasattr(self._app_instance.api, 'HParameterSet'):
            return self._app_instance.api.HParameterSet
            
        return None

    def _sync_find_replace_to_global(self, local_node, global_node):
        """Copy FindReplace values from local to global HParameterSet."""
        # Sync string properties
        string_props = ['FindString', 'ReplaceString', 'FindStyle', 'ReplaceStyle']
        for prop in string_props:
            if hasattr(local_node, prop) and hasattr(global_node, prop):
                try:
                    value = getattr(local_node, prop)
                    setattr(global_node, prop, value)
                except Exception:
                    pass
        
        # Sync boolean properties
        bool_props = [
            'MatchCase', 'AllWordForms', 'SeveralWords', 'UseWildCards', 
            'WholeWordOnly', 'AutoSpell', 'ReplaceMode', 'IgnoreFindString',
            'IgnoreReplaceString', 'IgnoreMessage', 'HanjaFromHangul', 
            'FindJaso', 'FindRegExp', 'FindType'
        ]
        for prop in bool_props:
            if hasattr(local_node, prop) and hasattr(global_node, prop):
                try:
                    value = getattr(local_node, prop)
                    setattr(global_node, prop, value)
                except Exception:
                    pass
        
        # Sync direction property
        if hasattr(local_node, 'Direction') and hasattr(global_node, 'Direction'):
            try:
                value = getattr(local_node, 'Direction')
                setattr(global_node, 'Direction', value)
            except Exception:
                pass

    def _sync_char_shape_to_global(self, local_node, global_node):
        """Copy CharShape values from local to global HParameterSet."""
        char_props = ['Bold', 'Italic', 'Underline', 'StrikeOut', 'TextColor', 'ShadeColor']
        for prop in char_props:
            if hasattr(local_node, prop) and hasattr(global_node, prop):
                try:
                    value = getattr(local_node, prop)
                    setattr(global_node, prop, value)
                except Exception:
                    pass

    def _sync_para_shape_to_global(self, local_node, global_node):
        """Copy ParaShape values from local to global HParameterSet."""
        para_props = ['Align', 'HeadIndent', 'TailIndent', 'LineSpacing', 'PrevSpacing', 'NextSpacing']
        for prop in para_props:
            if hasattr(local_node, prop) and hasattr(global_node, prop):
                try:
                    value = getattr(local_node, prop)
                    setattr(global_node, prop, value)
                except Exception:
                    pass

 
    # ------ descriptor hooks (staged-aware) ------
    def _ps_get(self, desc: PropertyDescriptor):
        key = desc.key
        if key in self._deleted:
            return None
        if key in self._staged:
            return self._staged[key]
        return self._snapshot.get(key, None)

    def _ps_set(self, desc: PropertyDescriptor, value: Any):
        key = desc.key
        self._deleted.discard(key)
        self._staged[key] = value
        # If setting a nested PS directly, keep cache aligned
        if isinstance(value, ParameterSet):
            self._wrapper_cache[key] = value

    def _ps_del(self, desc: PropertyDescriptor):
        key = desc.key
        self._staged.pop(key, None)
        self._deleted.add(key)
        # Deleting clears any cached wrapper for that key
        self._wrapper_cache.pop(key, None)
        return True

    # ------ conveniences ------
    def __getitem__(self, name: str):
        return getattr(self, name)

    def __setitem__(self, name: str, value):
        setattr(self, name, value)

    def _get_value(self, name):
        """Legacy method - use backend instead."""
        return self._backend.get(name)
    
    def _set_value(self, name, value):
        """Legacy method - use backend instead."""
        return self._backend.set(name, value)

    def _del_value(self, name):
        """Legacy method - use backend instead."""
        return self._backend.delete(name)

    def update(self, data: Dict[str, Any]):
        """Stage multiple values by attribute name (not raw keys)."""
        for n, v in data.items():
            if n in self._property_registry:
                setattr(self, n, v)
        return self

    def to_dict(
        self,
        *,
        include_defaults: bool = True,
        only: Optional[Iterable[str]] = None
    ) -> Dict[str, Any]:
        names = list(only) if only is not None else list(self._property_registry.keys())
        out = {}
        for n in names:
            val = getattr(self, n)  # staged-aware
            # For nested ParameterSets, show their own dict for readability
            if isinstance(val, ParameterSet):
                out[n] = val.to_dict(include_defaults=include_defaults)
            else:
                if include_defaults:
                    out[n] = val
                else:
                    desc = self._property_registry[n]
                    is_staged = desc.key in self._staged or desc.key in self._deleted
                    if is_staged or (desc.default is None or val != desc.default):
                        out[n] = val
        return out

    def _missing_required(self):
        missing = []
        for name, desc in self._property_registry.items():
            if desc.required:
                val = getattr(self, name)  # staged-aware
                is_missing = (val in (None, "", [], {}, ()))
                # If nested PS is required, also ensure it has no missing requireds
                if not is_missing and isinstance(val, ParameterSet):
                    nested_missing = val._missing_required()
                    is_missing = len(nested_missing) > 0
                if is_missing:
                    missing.append(name)
        return missing


    def dirty(self) -> Dict[str, Any]:
        """Return staged changes as {attr_name: value}, excluding deletions."""
        rev = {d.key: name for name, d in self._property_registry.items()}
        pretty = {}
        for k, v in self._staged.items():
            name = rev.get(k, k)
            pretty[name] = v.to_dict() if isinstance(v, ParameterSet) else v
        return pretty

    def deleted(self) -> set[str]:
        """Return attribute names marked for deletion."""
        rev = {d.key: name for name, d in self._property_registry.items()}
        return {rev.get(k, k) for k in self._deleted if k in rev}

    def __repr__(self):
        return f"<{self.__class__.__name__} staged={self.dirty()} deleted={self.deleted()}>"


# %% ../nbs/02_api/02_parameters.ipynb 22
# Additional methods for ParameterSet class
ParameterSet.update_from = lambda self, pset: self._update_from_impl(pset)
ParameterSet.serialize = lambda self: self._serialize_impl()
ParameterSet.__str__ = lambda self: self._str_impl()
ParameterSet.__repr__ = lambda self: self.__str__()

def _update_from_impl(self, pset):
    """Update this parameter set with values from another parameter set."""
    for key in self.attributes_names:
        value = getattr(pset, key, None)
        
        if isinstance(value, ParameterSet):
            # Recursively update nested parameter sets
            target = getattr(self, key)
            target.update_from(value)
        elif value is None:
            # Remove the attribute if value is None
            self._del_value(key)
        elif value:
            # Set the attribute if value is truthy, but handle validation errors gracefully
            try:
                setattr(self, key, value)
            except (ValueError, TypeError) as e:
                # Log validation errors but continue with other attributes
                import logging
                logging.warning(f"Skipping invalid value for '{key}': {value}. Error: {e}")
                continue
    return self

def _serialize_impl(self):
    """Convert the parameter set to a dictionary."""
    result = {}
    for key in self.attributes_names:
        value = getattr(self, key, None)
        if isinstance(value, ParameterSet):
            value = value.serialize()
        result[key] = value
    return result

def _str_impl(self):
    """String representation of the parameter set."""
    data = {
        "name": self.__class__.__name__, 
        "values": self.serialize()
    }
    return pprint.pformat(data, indent=4, width=60)

# Attach the implementations to the class
ParameterSet._update_from_impl = _update_from_impl
ParameterSet._serialize_impl = _serialize_impl
ParameterSet._str_impl = _str_impl


# %% ../nbs/02_api/02_parameters.ipynb 23
# Static methods for creating properties
@staticmethod        
def _typed_prop(key, doc, expected_type):
    """Create a property for typed parameter sets."""
    return TypedProperty(key, doc, expected_type)

@staticmethod      
def _int_prop(key, doc, min_val=None, max_val=None):
    """Create a property for integer values with optional range validation."""
    return IntProperty(key, doc, min_val, max_val)

@staticmethod 
def _bool_prop(key, doc):
    """Create a property for boolean values (0 or 1)."""
    return BoolProperty(key, doc)

@staticmethod 
def _color_prop(key, doc):
    """Create a property for color values with hex conversion."""
    return ColorProperty(key, doc)

@staticmethod 
def _unit_prop(key, unit, doc):
    """Create a property for unit-based values with automatic conversion."""
    return UnitProperty(key, unit, doc)

@staticmethod 
def _mapped_prop(key, mapping, doc):
    """Create a property for mapped values (string <-> integer)."""
    return MappedProperty(key, mapping, doc)

@staticmethod
def _str_prop(key, doc):
    """Create a property for string values."""
    return StringProperty(key, doc)

@staticmethod
def _int_list_prop(key, doc):
    """Create a property for lists of integers."""
    return ListProperty(key, doc, item_type=int)

@staticmethod
def _tuple_list_prop(key, doc):
    """Create a property for lists of (X, Y) coordinate tuples."""
    return ListProperty(key, doc, item_type=tuple)

@staticmethod
def _gradation_color_prop(key, doc):
    """Create a property for gradation color lists with hex conversion."""
    class GradationColorProperty(ListProperty):
        def __get__(self, instance, owner):
            if instance is None:
                return self
            value = self._get_value(instance)
            if value is None:
                return None
            return [convert_hwp_color_to_hex(color) for color in value]
        
        def __set__(self, instance, value):
            if value is None:
                return self._del_value(instance)
            if not isinstance(value, (list, tuple)):
                raise TypeError(f"Value for '{self.key}' must be a list or tuple")
            
            converted_colors = [convert_to_hwp_color(color) for color in value]
            return self._set_value(instance, converted_colors)
    
    return GradationColorProperty(key, doc, item_type=int, min_length=2, max_length=10)

# Attach static methods to ParameterSet class
ParameterSet._typed_prop = _typed_prop
ParameterSet._int_prop = _int_prop
ParameterSet._bool_prop = _bool_prop
ParameterSet._color_prop = _color_prop
ParameterSet._unit_prop = _unit_prop
ParameterSet._mapped_prop = _mapped_prop
ParameterSet._str_prop = _str_prop
ParameterSet._int_list_prop = _int_list_prop
ParameterSet._tuple_list_prop = _tuple_list_prop
ParameterSet._gradation_color_prop = _gradation_color_prop


# %% ../nbs/02_api/02_parameters.ipynb 25
class BorderFill(ParameterSet):
    """
    ### BorderFill

    5) BorderFill : 테두리/배경의 일반 속성

    | Item ID | Type | SubType | Description |
    | --- | --- | --- | --- |
    | BorderTypeLeft | PIT_UI2 |  | 4방향 테두리 종류 : 왼쪽 [선 종류] |
    | BorderTypeRight | PIT_UI2 |  | 4방향 테두리 종류 : 오른쪽 |
    | BorderTypeTop | PIT_UI2 |  | 4방향 테두리 종류 : 위 |
    | BorderTypeBottom | PIT_UI2 |  | 4방향 테두리 종류 : 아래 |
    | BorderWidthLeft | PIT_UI1 |  | 4방향 테두리 두께 : 왼쪽 [선 굵기] |
    | BorderWidthRight | PIT_UI1 |  | 4방향 테두리 두께 : 오른쪽 |
    | BorderWidthTop | PIT_UI1 |  | 4방향 테두리 두께 : 위 |
    | BorderWidthBottom | PIT_UI1 |  | 4방향 테두리 두께 : 아래 |
    | BorderColorLeft | PIT_UI4 |  | 4방향 테두리 색깔 : 왼쪽 (RGB color: 0x00BBGGRR) |
    | BorderColorRight | PIT_UI4 |  | 4방향 테두리 색깔 : 오른쪽 (RGB color: 0x00BBGGRR) |
    | BorderColorTop | PIT_UI4 |  | 4방향 테두리 색깔 : 위 (RGB color: 0x00BBGGRR) |
    | BorderColorBottom | PIT_UI4 |  | 4방향 테두리 색깔 : 아래 (정수값 그대로 사용) |
    | SlashFlag | PIT_UI2 |  | 대각선 플래그 (비트 플래그 조합) |
    | BackSlashFlag | PIT_UI2 |  | 역대각선 플래그 (비트 플래그 조합) |
    | DiagonalType | PIT_UI2 |  | 대각선 유형 (셀 또는 자동 분할 경계선에 사용) |
    | DiagonalWidth | PIT_UI1 |  | 대각선 두께 (셀 또는 자동 분할 경계선에 사용) |
    | DiagonalColor | PIT_UI4 |  | 대각선 색상 (RGB color: 0x00BBGGRR) |
    | BorderFill3D | PIT_UI1 |  | 3차원 효과: 0 = off, 1 = on |
    | Shadow | PIT_UI1 |  | 그림자 효과: 0 = off, 1 = on |
    | FillAttr | PIT_SET | DrawFillAttr | 배경 채우기 속성 |
    | CrookedSlashFlag | PIT_UI2 |  | 꺾인 대각선 플래그 (bit 0, 1) |
    | BreakCellSeparateLine | PIT_UI1 |  | 자동으로 나뉜 표의 경계선 설정: 0 = 기본, 1 = 사용자 설정 |
    | CounterSlashFlag | PIT_UI1 |  | 슬래쉬 대각선 역방향 플래그: 0 = 순방향, 1 = 역방향 |
    | CounterBackSlashFlag | PIT_UI1 |  | 역슬래쉬 대각선 역방향 플래그: 0 = 순방향, 1 = 역방향 |
    | CenterLineFlag | PIT_UI1 |  | 중심선 플래그: 0 = 없음, 1 = 있음 |
    | CrookedSlashFlag1 | PIT_UI1 |  | 슬래쉬 대각선 꺾임 여부 (저바이트) |
    | CrookedSlashFlag2 | PIT_UI1 |  | 역슬래쉬 대각선 꺾임 여부 (고바이트) |

    ※ 대각선의 형태는 다음의 3가지 아이템으로 결정됩니다:
      - SlashFlag (또는 BackSlashFlag)
      - CrookedSlashFlag1 (또는 CrookedSlashFlag2)
      - CounterSlashFlag (또는 CounterBackSlashFlag)
    """

    # Integer properties
    border_type_left = IntProperty("BorderTypeLeft", "테두리 유형 (왼쪽): 정수 값을 입력하세요.")
    border_type_right = IntProperty("BorderTypeRight", "테두리 유형 (오른쪽): 정수 값을 입력하세요.")
    border_type_top = IntProperty("BorderTypeTop", "테두리 유형 (위): 정수 값을 입력하세요.")
    border_type_bottom = IntProperty("BorderTypeBottom", "테두리 유형 (아래): 정수 값을 입력하세요.")

    border_width_left = IntProperty("BorderWidthLeft", "테두리 두께 (왼쪽): 정수 값을 입력하세요.")
    border_width_right = IntProperty("BorderWidthRight", "테두리 두께 (오른쪽): 정수 값을 입력하세요.")
    border_width_top = IntProperty("BorderWidthTop", "테두리 두께 (위): 정수 값을 입력하세요.")
    border_width_bottom = IntProperty("BorderWidthBottom", "테두리 두께 (아래): 정수 값을 입력하세요.")

    # Color properties (with conversion)
    border_color_left = ColorProperty("BorderColorLeft", "테두리 색상 (왼쪽): 정수 값을 입력하세요.")
    border_color_right = ColorProperty("BorderColorRight", "테두리 색상 (오른쪽): 정수 값을 입력하세요.")
    border_color_top = ColorProperty("BorderColorTop", "테두리 색상 (위): 정수 값을 입력하세요.")
    border_color_bottom = IntProperty("BorderColorBottom", "테두리 색상 (아래): 정수 값을 입력하세요.")

    # 대각선 색상 (setter now completes properly)
    diagonal_color = IntProperty("DiagonalColor", "대각선 색상: 정수 값을 입력하세요.")

    # Other integer properties
    slash_flag = IntProperty("SlashFlag", "대각선 플래그: 정수 값을 입력하세요.")
    backslash_flag = IntProperty("BackSlashFlag", "역대각선 플래그: 정수 값을 입력하세요.")
    diagonal_type = IntProperty("DiagonalType", "대각선 유형: 정수 값을 입력하세요.")
    diagonal_width = IntProperty("DiagonalWidth", "대각선 두께: 정수 값을 입력하세요.")
    crooked_slash_flag = IntProperty("CrookedSlashFlag", "꺾인 대각선 플래그 (bit 0, 1): 정수 값을 입력하세요.")

    # Boolean properties
    border_fill_3d = BoolProperty("BorderFill3D", "3차원 효과: 0 = off, 1 = on")
    shadow = BoolProperty("Shadow", "그림자 효과: 0 = off, 1 = on")
    break_cell_separate_line = BoolProperty("BreakCellSeparateLine", "자동으로 나뉜 표의 경계선 설정: 0 = 기본, 1 = 사용자 설정")
    counter_slash_flag = BoolProperty("CounterSlashFlag", "슬래쉬 대각선의 역방향 플래그: 0 = 순방향, 1 = 역방향")
    counter_back_slash_flag = BoolProperty("CounterBackSlashFlag", "역슬래쉬 대각선의 역방향 플래그: 0 = 순방향, 1 = 역방향")
    center_line_flag = BoolProperty("CenterLineFlag", "중심선 플래그: 0 = 없음, 1 = 있음")
    crooked_slash_flag1 = BoolProperty("CrookedSlashFlag1", "슬래쉬 대각선의 꺾임 여부 (저바이트): 0 = 아니오, 1 = 예")
    crooked_slash_flag2 = BoolProperty("CrookedSlashFlag2", "역슬래쉬 대각선의 꺾임 여부 (고바이트): 0 = 아니오, 1 = 예")

    # Typed property for fill attribute
    fill_attr = TypedProperty("FillAttr", "배경 채우기 속성", lambda: DrawFillAttr)


# %% ../nbs/02_api/02_parameters.ipynb 26
class Caption(ParameterSet):
    """
    ### Caption

    8) Caption : 캡션 속성

    | Item ID       | Type    | SubType | Description                                                                 |
    | ------------- | ------- | ------- | --------------------------------------------------------------------------- |
    | Side          | PIT_UI1 |         | 방향. 0 = 왼쪽, 1 = 오른쪽, 2 = 위, 3 = 아래                               |
    | Width         | PIT_I   |         | 캡션 폭 (가로 방향이면 높이를 사용함. 단위: HWPUNIT)                      |
    | Gap           | PIT_I   |         | 캡션과의 사이 간격 (단위: HWPUNIT)                                        |
    | CapFullSize   | PIT_UI1 |         | 캡션 폭에 여백을 포함할지 여부 (0 = 포함 안 함, 1 = 포함함)              |
    """

    # 'side' must be one of the allowed values
    side = MappedProperty("Side", DIRECTION_MAP, "방향: 0 = 왼쪽, 1 = 오른쪽, 2 = 위, 3 = 아래")

    # 'width' and 'gap' are stored in HWPUNIT; convert to/from mili
    width = UnitProperty("Width", "mili", "캡션 폭 (단위: HWPUNIT)")
    gap = UnitProperty("Gap", "mili", "캡션과의 간격 (단위: HWPUNIT)")

    # Mapping for 'cap_full_size': 0 means 'exclude', 1 means 'include'
    cap_full_size = MappedProperty("CapFullSize", CAP_FULL_SIZE_MAP, "캡션 폭에 여백 포함 여부 (CapFullSize): 0 = exclude, 1 = include")


# %% ../nbs/02_api/02_parameters.ipynb 27
class FindReplace(ParameterSet):
    """
    ### FindReplace

    56) FindReplace : 찾기/찾아 바꾸기

    | Item ID           | Type      | SubType | Description                                                               |
    |-------------------|-----------|---------|---------------------------------------------------------------------------|
    | FindString        | PIT_BSTR  |         | 찾을 문자열                                                              |
    | ReplaceString     | PIT_BSTR  |         | 바꿀 문자열                                                              |
    | Direction         | PIT_UI1   |         | 찾을 방향 : 0 = 아래쪽, 1 = 위쪽, 2 = 문서 전체                           |
    | MatchCase         | PIT_UI1   |         | 대소문자 구별 (on/off)                                                     |
    | AllWordForms      | PIT_UI1   |         | 모든 단어 형태 (on/off)                                                   |
    | SeveralWords      | PIT_UI1   |         | 여러 단어 찾기 (on/off)                                                    |
    | UseWildCards      | PIT_UI1   |         | 와일드카드 사용 (on/off)                                                   |
    | WholeWordOnly     | PIT_UI1   |         | 전체 단어만 찾기 (on/off)                                                   |
    | AutoSpell         | PIT_UI1   |         | 자동 맞춤법 사용 (on/off)                                                  |
    | ReplaceMode       | PIT_UI1   |         | 찾아 바꾸기 모드 (on/off)                                                  |
    | IgnoreFindString  | PIT_UI1   |         | 찾을 문자열 무시 (on/off)                                                  |
    | IgnoreReplaceString| PIT_UI1  |         | 바꿀 문자열 무시 (on/off)                                                   |
    | FindCharShape     | PIT_SET   | CharShape | 찾을 글자 모양                                                          |
    | FindParaShape     | PIT_SET   | ParaShape | 찾을 문단 모양                                                          |
    | ReplaceCharShape  | PIT_SET   | CharShape | 바꿀 글자 모양                                                          |
    | ReplaceParaShape  | PIT_SET   | ParaShape | 바꿀 문단 모양                                                          |
    | FindStyle         | PIT_BSTR  |         | 찾을 스타일                                                              |
    | ReplaceStyle      | PIT_BSTR  |         | 바꿀 스타일                                                              |
    | IgnoreMessage     | PIT_UI1   |         | 메시지박스 표시 안함 (on/off)                                              |
    | HanjaFromHangul   | PIT_UI1   |         | 한글임으로 한자 차기                                                      |
    | FindJaso          | PIT_UI1   |         | 자소로 찾기 (on/off)                                                      |
    | FindRegExp        | PIT_UI1   |         | 정규식(조건식)으로 찾기 (on/off)                                           |
    | FindType          | PIT_UI1   |         | 찾기 유형 (on/off)                                                       |
    """

    def __init__(self, parameterset=None):
        super().__init__(parameterset)
        self.attributes_names = [
            "find_string",
            "replace_string",
            "find_style",
            "replace_style",
            "direction",
            "match_case",
            "all_word_forms",
            "several_words",
            "use_wildcards",
            "whole_word_only",
            "auto_spell",
            "replace_mode",
            "ignore_find_string",
            "ignore_replace_string",
            "ignore_message",
            "hanja_from_hangul",
            "find_jaso",
            "find_regexp",
            "find_type",
            "find_charshape",
            "find_parashape",
            "replace_charshape",
            "replace_parashape",
        ]

    # String properties
    find_string = StringProperty("FindString", "찾을 문자열")
    replace_string = StringProperty("ReplaceString", "바꿀 문자열")
    find_style = StringProperty("FindStyle", "찾을 스타일")
    replace_style = StringProperty("ReplaceStyle", "바꿀 스타일")

    # Enum property for direction
    direction = MappedProperty(
        "Direction",
        SEARCH_DIRECTION_MAP,
        "찾을 방향: 0 = 아래쪽, 1 = 위쪽, 2 = 문서 전체",
    )

    # Boolean properties (on/off flags)
    match_case = BoolProperty("MatchCase", "대소문자 구별 (on/off)")
    all_word_forms = BoolProperty("AllWordForms", "모든 단어 형태 (on/off)")
    several_words = BoolProperty("SeveralWords", "여러 단어 찾기 (on/off)")
    use_wildcards = BoolProperty("UseWildCards", "와일드카드 사용 (on/off)")
    whole_word_only = BoolProperty(
        "WholeWordOnly", "전체 단어만 찾기 (on/off)"
    )
    auto_spell = BoolProperty("AutoSpell", "자동 맞춤법 사용 (on/off)")
    find_jaso = BoolProperty("FindJaso", "자소로 찾기 (on/off)")
    find_regexp = BoolProperty("FindRegExp", "정규식 찾기 (on/off)")
    find_type = BoolProperty("FindType", "찾기 유형 (on/off)")

    ignore_replace_string = BoolProperty(
        "IgnoreReplaceString", "바꿀 문자열 무시 (on/off)"
    )
    ignore_message = BoolProperty(
        "IgnoreMessage", "메시지박스 표시 안함 (on/off)"
    )
    hanja_from_hangul = BoolProperty(
        "HanjaFromHangul", "한글임으로 한자 차기"
    )
    find_jaso = BoolProperty("FindJaso", "자소로 찾기 (on/off)")
    find_regexp = BoolProperty("FindRegExp", "정규식 찾기 (on/off)")
    find_type = BoolProperty("FindType", "찾기 유형 (on/off)")

    # Composite properties using _typed_prop
    find_charshape = TypedProperty(
        "FindCharShape", "찾을 글자 모양", lambda: CharShape
    )
    find_parashape = TypedProperty(
        "FindParaShape", "찾을 문단 모양", lambda: ParaShape
    )
    replace_charshape = TypedProperty(
        "ReplaceCharShape", "바꿀 글자 모양", lambda: CharShape
    )
    replace_parashape = TypedProperty(
        "ReplaceParaShape", "바꿀 문단 모양", lambda: ParaShape
    )


# %% ../nbs/02_api/02_parameters.ipynb 28
# Forward declarations for commonly referenced parameter sets
# These are minimal implementations - full implementations would be added as needed

class DrawFillAttr(ParameterSet):
    """DrawFillAttr parameter set - placeholder implementation"""
    pass

class CharShape(ParameterSet):
    """CharShape parameter set - placeholder implementation"""
    pass

class ParaShape(ParameterSet):
    """ParaShape parameter set - placeholder implementation"""
    pass

class ShapeObject(ParameterSet):
    """ShapeObject parameter set - placeholder implementation"""
    pass

class Table(ParameterSet):
    """Table parameter set - placeholder implementation"""
    pass


# %% ../nbs/02_api/02_parameters.ipynb 30
# Direction mappings
DIRECTION_MAP = {"left": 0, "right": 1, "top": 2, "bottom": 3}

# Size and alignment mappings
CAP_FULL_SIZE_MAP = {"exclude": 0, "include": 1}
ALIGNMENT_MAP = {"left": 0, "center": 1, "right": 2}
VERT_ALIGN_MAP = {"top": 0, "center": 1, "bottom": 2}
VERT_REL_TO_MAP = {"paper": 0, "page": 1, "paragraph": 2}
HORZ_REL_TO_MAP = {"paper": 0, "page": 1, "column": 2, "paragraph": 3}
HORZ_ALIGN_MAP = {"left": 0, "center": 1, "right": 2, "inside": 3, "outside": 4}
ALIGN_MAP = {"left": 0, "center": 1, "right": 2}
ALIGN_TYPE_MAP = {"between": 0, "left": 1, "right": 2, "center": 3, "ratio": 4, "shared": 5}

# Font and text mappings
FONTTYPE_MAP = {"don't care": 0, "TTF": 1, "HFT": 2, "dontcare": 0, "ttf": 1, "htf": 2}
SHADOW_TYPE_MAP = {"none": 0, "drop": 1, "continuous": 2}
UNDERLINE_TYPE_MAP = {"none": 0, "bottom": 1, "center": 2, "top": 3}
OUTLINE_TYPE_MAP = {
    "none": 0,
    "solid": 1,
    "dot": 2,
    "thick": 3,
    "dash": 4,
    "dashdot": 5,
    "dashdotdot": 6,
}
STRIKEOUT_TYPE_MAP = {
    "none": 0,
    "red single": 1,
    "red double": 2,
    "text single": 3,
    "text double": 4,
}
USE_KERNING_MAP = {"off": 0, "on": 1}
DIAC_SYM_MARK_MAP = {"none": 0, "black circle": 1, "empty circle": 2}
USE_FONT_SPACE_MAP = {"off": 0, "on": 1}

# Background and fill mappings
BACKGROUND_TYPE_MAP = {"empty": 0, "fill": 1, "picture": 2, "gradation": 3}
GRADATION_TYPE_MAP = {"stripe": 1, "circle": 2, "cone": 3, "square": 4}
ROTATION_SETTING_MAP = {"none": 0, "setted_rotation": 1, "picture_centered_rotation": 2, "rotation_and_centered": 3}

# Search and text flow mappings
SEARCH_DIRECTION_MAP = {"down": 0, "up": 1, "doc": 2}
TEXT_DIRECTION_MAP = {"horizontal": 0, "vertical": 1}
LINE_WRAP_MAP = {"basic": 0, "no_newline": 1, "forced": 2}
TEXT_WRAP_MAP = {"square": 0, "top_bottom": 1, "behind": 2, "front": 3, "tight": 4, "through": 5}
TEXT_FLOW_MAP = {"both": 0, "left": 1, "right": 2, "largest": 3}

# Line break and text alignment mappings
LATIN_LINE_BREAK_MAP = {"word": 0, "hyphen": 1, "letter": 2}
NONLATIN_LINE_BREAK_MAP = {"word": 0, "letter": 1}
TEXT_ALIGN_MAP = {"font": 0, "up": 1, "middle": 2, "down": 3}

# Heading and border mappings
HEADING_TYPE_MAP = {"none": 0, "outline": 1, "number": 2, "bullet": 3}
BORDER_TEXT_MAP = {"column": 0, "text": 1}

# Numbering mappings
NUMBERING_TYPE_MAP = {"none": 0, "picture": 1, "table": 2, "equation": 3}
NUMBER_FORMAT_MAP = {
    "1": 0,
    "circled 1": 1,
    "I": 2,
    "i": 3,
    "A": 4,
    "a": 5,
    "circled A": 6,
    "circled a": 7,
    "가": 8,
    "동그라미 가": 9,
    "ㄱ": 10,
    "동그라미 ㄱ": 11,
    "일": 12,
    "一": 13,
    "동그라미 一": 14
}

# Line spacing and effects mappings
LINE_SPACING_TYPE_MAP = {"font": 0, "fixed": 1, "space": 2}
PIC_EFFECT_MAP = {"none": 0, "bw": 1, "sepia": 2}
PAGE_BREAK_MAP = {"none": 0, "cell": 1, "text": 2}

# %% ../nbs/02_api/02_parameters.ipynb 32
class BorderFill(ParameterSet):
    """
    ### BorderFill

    5) BorderFill : 테두리/배경의 일반 속성

    | Item ID | Type | SubType | Description |
    | --- | --- | --- | --- |
    | BorderTypeLeft | PIT_UI2 |  | 4방향 테두리 종류 : 왼쪽 [선 종류] |
    | BorderTypeRight | PIT_UI2 |  | 4방향 테두리 종류 : 오른쪽 |
    | BorderTypeTop | PIT_UI2 |  | 4방향 테두리 종류 : 위 |
    | BorderTypeBottom | PIT_UI2 |  | 4방향 테두리 종류 : 아래 |
    | BorderWidthLeft | PIT_UI1 |  | 4방향 테두리 두께 : 왼쪽 [선 굵기] |
    | BorderWidthRight | PIT_UI1 |  | 4방향 테두리 두께 : 오른쪽 |
    | BorderWidthTop | PIT_UI1 |  | 4방향 테두리 두께 : 위 |
    | BorderWidthBottom | PIT_UI1 |  | 4방향 테두리 두께 : 아래 |
    | BorderColorLeft | PIT_UI4 |  | 4방향 테두리 색깔 : 왼쪽 (RGB color: 0x00BBGGRR) |
    | BorderColorRight | PIT_UI4 |  | 4방향 테두리 색깔 : 오른쪽 (RGB color: 0x00BBGGRR) |
    | BorderColorTop | PIT_UI4 |  | 4방향 테두리 색깔 : 위 (RGB color: 0x00BBGGRR) |
    | BorderColorBottom | PIT_UI4 |  | 4방향 테두리 색깔 : 아래 (정수값 그대로 사용) |
    | SlashFlag | PIT_UI2 |  | 대각선 플래그 (비트 플래그 조합) |
    | BackSlashFlag | PIT_UI2 |  | 역대각선 플래그 (비트 플래그 조합) |
    | DiagonalType | PIT_UI2 |  | 대각선 유형 (셀 또는 자동 분할 경계선에 사용) |
    | DiagonalWidth | PIT_UI1 |  | 대각선 두께 (셀 또는 자동 분할 경계선에 사용) |
    | DiagonalColor | PIT_UI4 |  | 대각선 색상 (RGB color: 0x00BBGGRR) |
    | BorderFill3D | PIT_UI1 |  | 3차원 효과: 0 = off, 1 = on |
    | Shadow | PIT_UI1 |  | 그림자 효과: 0 = off, 1 = on |
    | FillAttr | PIT_SET | DrawFillAttr | 배경 채우기 속성 |
    | CrookedSlashFlag | PIT_UI2 |  | 꺾인 대각선 플래그 (bit 0, 1) |
    | BreakCellSeparateLine | PIT_UI1 |  | 자동으로 나뉜 표의 경계선 설정: 0 = 기본, 1 = 사용자 설정 |
    | CounterSlashFlag | PIT_UI1 |  | 슬래쉬 대각선 역방향 플래그: 0 = 순방향, 1 = 역방향 |
    | CounterBackSlashFlag | PIT_UI1 |  | 역슬래쉬 대각선 역방향 플래그: 0 = 순방향, 1 = 역방향 |
    | CenterLineFlag | PIT_UI1 |  | 중심선 플래그: 0 = 없음, 1 = 있음 |
    | CrookedSlashFlag1 | PIT_UI1 |  | 슬래쉬 대각선 꺾임 여부 (저바이트) |
    | CrookedSlashFlag2 | PIT_UI1 |  | 역슬래쉬 대각선 꺾임 여부 (고바이트) |

    ※ 대각선의 형태는 다음의 3가지 아이템으로 결정됩니다:
      - SlashFlag (또는 BackSlashFlag)
      - CrookedSlashFlag1 (또는 CrookedSlashFlag2)
      - CounterSlashFlag (또는 CounterBackSlashFlag)
    """

    def __init__(self, parameterset=None):
        super().__init__(parameterset)
        self.attributes_names = [
            "border_type_left",
            "border_type_right",
            "border_type_top",
            "border_type_bottom",
            "border_width_left",
            "border_width_right",
            "border_width_top",
            "border_width_bottom",
            "border_color_left",
            "border_color_right",
            "border_color_top",
            "border_color_bottom",
            "diagonal_color",
            "slash_flag",
            "backslash_flag",
            "diagonal_type",
            "diagonal_width",
            "crooked_slash_flag",
            "border_fill_3d",
            "shadow",
            "break_cell_separate_line",
            "counter_slash_flag",
            "counter_back_slash_flag",
            "center_line_flag",
            "crooked_slash_flag1",
            "crooked_slash_flag2",
            "fill_attr",
        ]

    # Integer properties
    border_type_left = ParameterSet._int_prop(
        "BorderTypeLeft", "테두리 유형 (왼쪽): 정수 값을 입력하세요."
    )
    border_type_right = ParameterSet._int_prop(
        "BorderTypeRight", "테두리 유형 (오른쪽): 정수 값을 입력하세요."
    )
    border_type_top = ParameterSet._int_prop(
        "BorderTypeTop", "테두리 유형 (위): 정수 값을 입력하세요."
    )
    border_type_bottom = ParameterSet._int_prop(
        "BorderTypeBottom", "테두리 유형 (아래): 정수 값을 입력하세요."
    )

    border_width_left = ParameterSet._int_prop(
        "BorderWidthLeft", "테두리 두께 (왼쪽): 정수 값을 입력하세요."
    )
    border_width_right = ParameterSet._int_prop(
        "BorderWidthRight", "테두리 두께 (오른쪽): 정수 값을 입력하세요."
    )
    border_width_top = ParameterSet._int_prop(
        "BorderWidthTop", "테두리 두께 (위): 정수 값을 입력하세요."
    )
    border_width_bottom = ParameterSet._int_prop(
        "BorderWidthBottom", "테두리 두께 (아래): 정수 값을 입력하세요."
    )

    # Color properties (with conversion)
    border_color_left = ParameterSet._color_prop(
        "BorderCorlorLeft", "테두리 색상 (왼쪽): 정수 값을 입력하세요."
    )
    border_color_right = ParameterSet._color_prop(
        "BorderColorRight", "테두리 색상 (오른쪽): 정수 값을 입력하세요."
    )
    border_color_top = ParameterSet._color_prop(
        "BorderColorTop", "테두리 색상 (위): 정수 값을 입력하세요."
    )
    border_color_bottom = ParameterSet._int_prop(
        "BorderColorBottom", "테두리 색상 (아래): 정수 값을 입력하세요."
    )

    # 대각선 색상 (setter now completes properly)
    diagonal_color = ParameterSet._int_prop(
        "DiagonalColor", "대각선 색상: 정수 값을 입력하세요."
    )

    # Other integer properties
    slash_flag = ParameterSet._int_prop(
        "SlashFlag", "대각선 플래그: 정수 값을 입력하세요."
    )
    backslash_flag = ParameterSet._int_prop(
        "BackSlashFlag", "역대각선 플래그: 정수 값을 입력하세요."
    )
    diagonal_type = ParameterSet._int_prop(
        "DiagonalType", "대각선 유형: 정수 값을 입력하세요."
    )
    diagonal_width = ParameterSet._int_prop(
        "DiagonalWidth", "대각선 두께: 정수 값을 입력하세요."
    )
    crooked_slash_flag = ParameterSet._int_prop(
        "CrookedSlashFlag", "꺾인 대각선 플래그 (bit 0, 1): 정수 값을 입력하세요."
    )

    # Boolean properties
    border_fill_3d = ParameterSet._bool_prop(
        "BorderFill3D", "3차원 효과: 0 = off, 1 = on"
    )
    shadow = ParameterSet._bool_prop("Shadow", "그림자 효과: 0 = off, 1 = on")
    break_cell_separate_line = ParameterSet._bool_prop(
        "BreakCellSeparateLine",
        "자동으로 나뉜 표의 경계선 설정: 0 = 기본, 1 = 사용자 설정",
    )
    counter_slash_flag = ParameterSet._bool_prop(
        "CounterSlashFlag", "슬래쉬 대각선의 역방향 플래그: 0 = 순방향, 1 = 역방향"
    )
    counter_back_slash_flag = ParameterSet._bool_prop(
        "CounterBackSlashFlag",
        "역슬래쉬 대각선의 역방향 플래그: 0 = 순방향, 1 = 역방향",
    )
    center_line_flag = ParameterSet._bool_prop(
        "CenterLineFlag", "중심선 플래그: 0 = 없음, 1 = 있음"
    )
    crooked_slash_flag1 = ParameterSet._bool_prop(
        "CrookedSlashFlag1", "슬래쉬 대각선의 꺾임 여부 (저바이트): 0 = 아니오, 1 = 예"
    )
    crooked_slash_flag2 = ParameterSet._bool_prop(
        "CrookedSlashFlag2",
        "역슬래쉬 대각선의 꺾임 여부 (고바이트): 0 = 아니오, 1 = 예",
    )

    # Typed property for fill attribute
    fill_attr = ParameterSet._typed_prop("FillAttr", "배경 채우기 속성", lambda: DrawFillAttr)

# %% ../nbs/02_api/02_parameters.ipynb 34
class Caption(ParameterSet):
    """
    ### Caption

    8) Caption : 캡션 속성

    | Item ID       | Type    | SubType | Description                                                                 |
    | ------------- | ------- | ------- | --------------------------------------------------------------------------- |
    | Side          | PIT_UI1 |         | 방향. 0 = 왼쪽, 1 = 오른쪽, 2 = 위, 3 = 아래                               |
    | Width         | PIT_I   |         | 캡션 폭 (가로 방향이면 높이를 사용함. 단위: HWPUNIT)                      |
    | Gap           | PIT_I   |         | 캡션과의 사이 간격 (단위: HWPUNIT)                                        |
    | CapFullSize   | PIT_UI1 |         | 캡션 폭에 여백을 포함할지 여부 (0 = 포함 안 함, 1 = 포함함)              |
    """

    def __init__(self, parameterset=None):
        super().__init__(parameterset)
        self.attributes_names = [
            "side",
            "width",
            "gap",
            "cap_full_size",
        ]

    # 'side' must be one of the allowed values
    side = ParameterSet._mapped_prop(
        "Side", DIRECTION_MAP, doc="방향: 0 = 왼쪽, 1 = 오른쪽, 2 = 위, 3 = 아래"
    )

    # 'width' and 'gap' are stored in HWPUNIT; convert to/from mili
    width = ParameterSet._unit_prop("Width", unit="mili", doc="캡션 폭 (단위: HWPUNIT)")
    gap = ParameterSet._unit_prop("Gap", unit="mili", doc="캡션과의 간격 (단위: HWPUNIT)")

    # Mapping for 'cap_full_size': 0 means 'exclude', 1 means 'include'
    cap_full_size = ParameterSet._mapped_prop(
        "CapFullSize",
        mapping=CAP_FULL_SIZE_MAP,
        doc="캡션 폭에 여백 포함 여부 (CapFullSize): 0 = exclude, 1 = include",
    )


# %% ../nbs/02_api/02_parameters.ipynb 36
class BulletShape(ParameterSet):
    """
    ### BulletShape

    | Item ID        | Type     | SubType        | Description |
    |----------------|----------|----------------|-------------|
    | HasCharShape   | PIT_UI1  |                | 글자 모양 사용 여부: 0 = 기본, 1 = 사용자 정의 |
    | CharShape      | PIT_SET  | CharShape      | 글자 모양 (HasCharShape가 1일 경우 사용) |
    | WidthAdjust    | PIT_I    |                | 글자 크기 보정 값 (HWPUNIT) |
    | TextOffset     | PIT_I    |                | 텍스트 오프셋 (percent or HWPUNIT) |
    | Alignment      | PIT_UI1  |                | 정렬 방식: 0 = 왼쪽, 1 = 가운데, 2 = 오른쪽 |
    | UseInstWidth   | PIT_UI1  |                | 인스턴스 폭 사용 여부 (on/off) |
    | AutoIndent     | PIT_UI1  |                | 자동 들여쓰기 (on/off) |
    | TextOffsetType | PIT_UI1  |                | 텍스트 오프셋 타입: 0 = percent, 1 = HWPUNIT |
    | BulletChar     | PIT_UI2  |                | 글머리 기호 문자 |
    | HasImage       | PIT_UI1  |                | 이미지 글머리 기호 여부: 0 = 없음, 1 = 있음 |
    | BulletImage    | PIT_SET  | DrawImageAttr  | 글머리 기호 이미지 |
    """

    def __init__(self, parameterset=None):
        super().__init__(parameterset)
        self.attributes_names = [
            "has_char_shape",
            "char_shape",
            "width_adjust",
            "text_offset",
            "alignment",
            "use_inst_width",
            "auto_indent",
            "text_offset_type",
            "bullet_char",
            "has_image",
            "bullet_image",
        ]

    has_char_shape = ParameterSet._bool_prop(
        "HasCharShape", "글자 모양 사용 여부: 0 = 기본, 1 = 사용자 정의"
    )
    char_shape = ParameterSet._typed_prop("CharShape", "글자 모양", lambda: CharShape)
    width_adjust = ParameterSet._int_prop("WidthAdjust", "글자 크기 보정 값 (HWPUNIT)")
    text_offset = ParameterSet._int_prop(
        "TextOffset", "텍스트 오프셋 (percent or HWPUNIT)"
    )
    alignment = ParameterSet._mapped_prop(
        "Alignment",
        ALIGNMENT_MAP,
        doc="정렬 방식: 0 = 왼쪽, 1 = 가운데, 2 = 오른쪽",
    )
    use_inst_width = ParameterSet._bool_prop(
        "UseInstWidth", "인스턴스 폭 사용 여부 (on/off)"
    )
    auto_indent = ParameterSet._bool_prop("AutoIndent", "자동 들여쓰기 (on/off)")
    text_offset_type = ParameterSet._bool_prop(
        "TextOffsetType", "텍스트 오프셋 타입: 0 = percent, 1 = HWPUNIT"
    )
    bullet_char = ParameterSet._int_prop("BulletChar", "글머리 기호 문자")
    has_image = ParameterSet._bool_prop(
        "HasImage", "이미지 글머리 기호 여부: 0 = 없음, 1 = 있음"
    )
    bullet_image = ParameterSet._typed_prop(
        "BulletImage", "글머리 기호 이미지", lambda: DrawImageAttr
    )

# %% ../nbs/02_api/02_parameters.ipynb 38
class Cell(ParameterSet):
    """
    ### Cell

    10) Cell : 셀 속성 정의

    | Item ID      | Type     | SubType   | Description                   |
    |--------------|----------|-----------|-------------------------------|
    | HasMargin    | PIT_UI1  |           | 셀 여백 여부 (on / off)       |
    | Protected    | PIT_UI1  |           | 보호 설정 여부: 0 = off, 1 = on|
    | Header       | PIT_UI1  |           | 헤더 여부: 0 = off, 1 = on     |
    | Width        | PIT_I4   |           | 셀의 너비 (HWPUNIT)           |
    | Height       | PIT_I4   |           | 셀의 높이 (HWPUNIT)           |
    | Editable     | PIT_UI1  |           | 편집 가능 여부: 0 = off, 1 = on|
    | Dirty        | PIT_UI1  |           | 변경 여부: 0 = off, 1 = on     |
    | CellCtrlData | PIT_SET  | CtrlData  | 셀 제어 데이터               |
    """

    def __init__(self, parameterset=None):
        super().__init__(parameterset)
        self.attributes_names = [
            "has_margin",
            "protected",
            "header",
            "width",
            "height",
            "editable",
            "dirty",
            "cell_ctrl_data",
        ]

    has_margin = ParameterSet._bool_prop(
        "HasMargin", "셀 여백 여부 (on / off): 0 또는 1."
    )
    protected = ParameterSet._bool_prop("Protected", "보호 설정 여부: 0 = off, 1 = on.")
    header = ParameterSet._bool_prop("Header", "헤더 여부: 0 = off, 1 = on.")
    width = ParameterSet._unit_prop("Width", "mili", "셀의 너비 (mm).")
    height = ParameterSet._unit_prop("Height", "mili", "셀의 높이 (mm).")
    editable = ParameterSet._bool_prop("Editable", "편집 가능 여부: 0 = off, 1 = on.")
    dirty = ParameterSet._bool_prop("Dirty", "변경 여부: 0 = off, 1 = on.")
    cell_ctrl_data = ParameterSet._typed_prop(
        "CellCtrlData", "셀 제어 데이터", lambda: CtrlData
    )

# %% ../nbs/02_api/02_parameters.ipynb 40
class CharShape(ParameterSet):
    """
        ### CharShape

        13) CharShape : 글자 모양


    | Item ID | Type | SubType | Description |
    | --- | --- | --- | --- |
    | FaceNameHangul | PIT_BSTR |  | 글꼴 이름 (한글) |
    | FaceNameLatin | PIT_BSTR |  | 글꼴 이름 (영문) |
    | FaceNameHanja | PIT_BSTR |  | 글꼴 이름 (한자) |
    | FaceNameJapanese | PIT_BSTR |  | 글꼴 이름 (일본어) |
    | FaceNameOther | PIT_BSTR |  | 글꼴 이름 (기타) |
    | FaceNameSymbol | PIT_BSTR |  | 글꼴 이름 (심벌) |
    | FaceNameUser | PIT_BSTR |  | 글꼴 이름 (사용자) |
    | FontTypeHangul | PIT_UI1 |  | 폰트 종류 (한글) : 0 = don't care, 1 = TTF, 2 = HFT |
    | FontTypeLatin | PIT_UI1 |  | 폰트 종류 (영문) : 0 = don't care, 1 = TTF, 2 = HFT |
    | FontTypeHanja | PIT_UI1 |  | 폰트 종류 (한자) : 0 = don't care, 1 = TTF, 2 = HFT |
    | FontTypeJapanese | PIT_UI1 |  | 폰트 종류 (일본어) : 0 = don't care, 1 = TTF, 2 = HFT |
    | FontTypeOther | PIT_UI1 |  | 폰트 종류 (기타) : 0 = don't care, 1 = TTF, 2 = HFT |
    | FontTypeSymbol | PIT_UI1 |  | 폰트 종류 (심벌) : 0 = don't care, 1 = TTF, 2 = HFT |
    | FontTypeUser | PIT_UI1 |  | 폰트 종류 (사용자) : 0 = don't care, 1 = TTF, 2 = HFT |
    | SizeHangul | PIT_UI1 |  | 각 언어별 크기 비율. (한글) 10% - 250% |
    | SizeLatin | PIT_UI1 |  | 각 언어별 크기 비율. (영문) 10% - 250% |
    | SizeHanja | PIT_UI1 |  | 각 언어별 크기 비율. (한자) 10% - 250% |
    | SizeJapanese | PIT_UI1 |  | 각 언어별 크기 비율. (일본어) 10% - 250% |
    | SizeOther | PIT_UI1 |  | 각 언어별 크기 비율. (기타) 10% - 250% |
    | SizeSymbol | PIT_UI1 |  | 각 언어별 크기 비율. (심벌) 10% - 250% |
    | SizeUser | PIT_UI1 |  | 각 언어별 크기 비율. (사용자) 10% - 250% |
    | RatioHangul | PIT_UI1 |  | 각 언어별 장평 비율. (한글) 50% - 200% |
    | RatioLatin | PIT_UI1 |  | 각 언어별 장평 비율. (영문) 50% - 200% |
    | RatioHanja | PIT_UI1 |  | 각 언어별 장평 비율. (한자) 50% - 200% |
    | RatioJapanese | PIT_UI1 |  | 각 언어별 장평 비율. (일본어) 50% - 200% |
    | RatioOther | PIT_UI1 |  | 각 언어별 장평 비율. (기타) 50% - 200% |
    | RatioSymbol | PIT_UI1 |  | 각 언어별 장평 비율. (심벌) 50% - 200% |
    | RatioUser | PIT_UI1 |  | 각 언어별 장평 비율. (사용자) 50% - 200% |
    | SpacingHangul | PIT_I1 |  | 각 언어별 자간. (한글) -50% - 50% |
    | SpacingLatin | PIT_I1 |  | 각 언어별 자간. (영문) -50% - 50% |
    | SpacingHanja | PIT_I1 |  | 각 언어별 자간. (한자) -50% - 50% |
    | SpacingJapanese | PIT_I1 |  | 각 언어별 자간. (일본어) -50% - 50% |
    | SpacingOther | PIT_I1 |  | 각 언어별 자간. (기타) -50% - 50% |
    | SpacingSymbol | PIT_I1 |  | 각 언어별 자간. (심벌) -50% - 50% |
    | SpacingUser | PIT_I1 |  | 각 언어별 자간. (사용자) -50% - 50% |
    | OffsetHangul | PIT_I1 |  | 각 언어별 오프셋. (한글) -100% - 100% |
    | OffsetLatin | PIT_I1 |  | 각 언어별 오프셋. (영문) -100% - 100% |
    | OffsetHanja | PIT_I1 |  | 각 언어별 오프셋. (한자) -100% - 100% |
    | OffsetJapanese | PIT_I1 |  | 각 언어별 오프셋. (일본어) -100% - 100% |
    | OffsetOther | PIT_I1 |  | 각 언어별 오프셋. (기타) -100% - 100% |
    | OffsetSymbol | PIT_I1 |  | 각 언어별 오프셋. (심벌) -100% - 100% |
    | OffsetUser | PIT_I1 |  | 각 언어별 오프셋. (사용자) -100% - 100% |
    | Bold | PIT_UI1 |  | Bold : 0 = off, 1 = on |
    | Italic | PIT_UI1 |  | Italic : 0 = off, 1 = on |
    | SmallCaps | PIT_UI1 |  | Small Caps : 0 = off, 1 = on |
    | Emboss | PIT_UI1 |  | Emboss : 0 = off, 1 = on |
    | Engrave | PIT_UI1 |  | Engrave : 0 = off, 1 = on |
    | SuperScript | PIT_UI1 |  | Superscript : 0 = off, 1 = on |
    | SubScript | PIT_UI1 |  | Subscript : 0 = off, 1 = on |
    | UnderlineType | PIT_UI1 |  | 밑줄 종류 :  0 = none, 1 = bottom, 2 = center, 3 = top |
    | OutlineType | PIT_UI1 |  | 외곽선 종류 : 0 = none, 1 = solid, 2 = dot, 3 = thick,  4 = dash, 5 = dashdot, 6 = dashdotdot |
    | ShadowType | PIT_UI1 |  | 그림자 종류 : 0 = none, 1 = drop, 2 = continuous |
    | TextColor | PIT_UI4 |  | 글자색. (COLORREF)RGB color를 나타내기 위한 32비트 값 (0x00BBGGRR) |
    | ShadeColor | PIT_UI4 |  | 음영색. (COLORREF)RGB color를 나타내기 위한 32비트 값 (0x00BBGGRR) |
    | UnderlineShape | PIT_UI1 |  | 밑줄 모양 : 선 종류 |
    | UnderlineColor | PIT_UI4 |  | 밑줄 색 (COLORREF)RGB color를 나타내기 위한 32비트 값 (0x00BBGGRR) |
    | ShadowOffsetX | PIT_I1 |  | 그림자 간격 (X 방향) -100% - 100% |
    | ShadowOffsetY | PIT_I1 |  | 그림자 간격 (Y 방향) -100% - 100% |
    | ShadowColor | PIT_UI4 |  | 그림자 색 (COLORREF)RGB color를 나타내기 위한 32비트 값 (0x00BBGGRR) |
    | StrikeOutType | PIT_UI1 |  | 취소선 종류 : 0 = none, 1 = red single, 2 = red double,  3 = text single, 4 = text double |
    | DiacSymMark | PIT_UI1 |  | 강조점 종류 : 0 = none, 1 = 검정 동그라미, 2 = 속 빈 동그라미 |
    | UseFontSpace | PIT_UI1 |  | 글꼴에 어울리는 빈칸 : 0 = off, 1 = on |
    | UseKerning | PIT_UI1 |  | 커닝 : 0 = off, 1 = on |
    | Height | PIT_I4 |  | 글자 크기 (HWPUNIT) |
    | BorderFill | PIT_SET | BorderFill | 테두리/배경 (한글2007에 새로 추가) |
    """

    def __init__(self, parameterset=None):
        super().__init__(parameterset)
        self.attributes_names = [
            "facename_hangul",
            "facename_latin",
            "facename_hanja",
            "facename_japanese",
            "facename_other",
            "facename_symbol",
            "facename_user",
            "fonttype_hangul",
            "fonttype_latin",
            "fonttype_hanja",
            "fonttype_japanese",
            "fonttype_other",
            "fonttype_symbol",
            "fonttype_user",
            "size_hangul",
            "size_latin",
            "size_hanja",
            "size_japanese",
            "size_other",
            "size_symbol",
            "size_user",
            "ratio_hangul",
            "ratio_latin",
            "ratio_hanja",
            "ratio_japanese",
            "ratio_other",
            "ratio_symbol",
            "ratio_user",
            "spacing_hangul",
            "spacing_latin",
            "spacing_hanja",
            "spacing_japanese",
            "spacing_other",
            "spacing_symbol",
            "spacing_user",
            "offset_hangul",
            "offset_latin",
            "offset_hanja",
            "offset_japanese",
            "offset_other",
            "offset_symbol",
            "offset_user",
            "bold",
            "italic",
            "small_caps",
            "emboss",
            "engrave",
            "superscript",
            "subscript",
            "underline_type",
            "underline_shape",
            "outline_type",
            "shadow_type",
            "text_color",
            "shade_color",
            "underline_color",
            "shadow_color",
            "shadow_offset_x",
            "shadow_offset_y",
            "strikeout_color",
            "strikeout_type",
            "strikeout_shape",
            "diac_sym_mark",
            "use_font_space",
            "use_kerning",
            "height",
            "border_fill",
        ]

    # Facename properties (strings)
    facename_hangul = ParameterSet._str_prop("FaceNameHangul", "글꼴 이름 (한글)")
    facename_latin = ParameterSet._str_prop("FaceNameLatin", "글꼴 이름 (영문)")
    facename_hanja = ParameterSet._str_prop("FaceNameHanja", "글꼴 이름 (한자)")
    facename_japanese = ParameterSet._str_prop("FaceNameJapanese", "글꼴 이름 (일본어)")
    facename_other = ParameterSet._str_prop("FaceNameOther", "글꼴 이름 (기타)")
    facename_symbol = ParameterSet._str_prop("FaceNameSymbol", "글꼴 이름 (심벌)")
    facename_user = ParameterSet._str_prop("FaceNameUser", "글꼴 이름 (사용자)")

    # FontType properties: mapped from numbers to human‐readable strings
    fonttype_hangul = ParameterSet._mapped_prop(
        "FontTypeHangul",
        FONTTYPE_MAP,
        "폰트 종류 (한글): 0 = don't care, 1 = TTF, 2 = HFT",
    )
    fonttype_latin = ParameterSet._mapped_prop(
        "FontTypeLatin",
        FONTTYPE_MAP,
        "폰트 종류 (영문): 0 = don't care, 1 = TTF, 2 = HFT",
    )
    fonttype_hanja = ParameterSet._mapped_prop(
        "FontTypeHanja",
        FONTTYPE_MAP,
        "폰트 종류 (한자): 0 = don't care, 1 = TTF, 2 = HFT",
    )
    fonttype_japanese = ParameterSet._mapped_prop(
        "FontTypeJapanese",
        FONTTYPE_MAP,
        "폰트 종류 (일본어): 0 = don't care, 1 = TTF, 2 = HFT",
    )
    fonttype_other = ParameterSet._mapped_prop(
        "FontTypeOther",
        FONTTYPE_MAP,
        "폰트 종류 (기타): 0 = don't care, 1 = TTF, 2 = HFT",
    )
    fonttype_symbol = ParameterSet._mapped_prop(
        "FontTypeSymbol",
        FONTTYPE_MAP,
        "폰트 종류 (심벌): 0 = don't care, 1 = TTF, 2 = HFT",
    )
    fonttype_user = ParameterSet._mapped_prop(
        "FontTypeUser",
        FONTTYPE_MAP,
        "폰트 종류 (사용자): 0 = don't care, 1 = TTF, 2 = HFT",
    )

    # Size properties (10% ~ 250%)
    size_hangul = ParameterSet._int_prop(
        "SizeHangul", "크기 (한글): 10% - 250%", 10, 250
    )
    size_latin = ParameterSet._int_prop("SizeLatin", "크기 (영문): 10% - 250%", 10, 250)
    size_hanja = ParameterSet._int_prop("SizeHanja", "크기 (한자): 10% - 250%", 10, 250)
    size_japanese = ParameterSet._int_prop(
        "SizeJapanese", "크기 (일본어): 10% - 250%", 10, 250
    )
    size_other = ParameterSet._int_prop("SizeOther", "크기 (기타): 10% - 250%", 10, 250)
    size_symbol = ParameterSet._int_prop(
        "SizeSymbol", "크기 (심벌): 10% - 250%", 10, 250
    )
    size_user = ParameterSet._int_prop("SizeUser", "크기 (사용자): 10% - 250%", 10, 250)

    # Ratio properties (50% ~ 200%)
    ratio_hangul = ParameterSet._int_prop(
        "RatioHangul", "장평 (한글): 50% - 200%", 50, 200
    )
    ratio_latin = ParameterSet._int_prop(
        "RatioLatin", "장평 (영문): 50% - 200%", 50, 200
    )
    ratio_hanja = ParameterSet._int_prop(
        "RatioHanja", "장평 (한자): 50% - 200%", 50, 200
    )
    ratio_japanese = ParameterSet._int_prop(
        "RatioJapanese", "장평 (일본어): 50% - 200%", 50, 200
    )
    ratio_other = ParameterSet._int_prop(
        "RatioOther", "장평 (기타): 50% - 200%", 50, 200
    )
    ratio_symbol = ParameterSet._int_prop(
        "RatioSymbol", "장평 (심벌): 50% - 200%", 50, 200
    )
    ratio_user = ParameterSet._int_prop(
        "RatioUser", "장평 (사용자): 50% - 200%", 50, 200
    )

    # Spacing properties (-50% ~ 50%)
    spacing_hangul = ParameterSet._int_prop(
        "SpacingHangul", "자간 (한글): -50% - 50%", -50, 50
    )
    spacing_latin = ParameterSet._int_prop(
        "SpacingLatin", "자간 (영문): -50% - 50%", -50, 50
    )
    spacing_hanja = ParameterSet._int_prop(
        "SpacingHanja", "자간 (한자): -50% - 50%", -50, 50
    )
    spacing_japanese = ParameterSet._int_prop(
        "SpacingJapanese", "자간 (일본어): -50% - 50%", -50, 50
    )
    spacing_other = ParameterSet._int_prop(
        "SpacingOther", "자간 (기타): -50% - 50%", -50, 50
    )
    spacing_symbol = ParameterSet._int_prop(
        "SpacingSymbol", "자간 (심벌): -50% - 50%", -50, 50
    )
    spacing_user = ParameterSet._int_prop(
        "SpacingUser", "자간 (사용자): -50% - 50%", -50, 50
    )

    # Offset properties (-100% ~ 100%)
    offset_hangul = ParameterSet._int_prop(
        "OffsetHangul", "오프셋 (한글): -100% - 100%", -100, 100
    )
    offset_latin = ParameterSet._int_prop(
        "OffsetLatin", "오프셋 (영문): -100% - 100%", -100, 100
    )
    offset_hanja = ParameterSet._int_prop(
        "OffsetHanja", "오프셋 (한자): -100% - 100%", -100, 100
    )
    offset_japanese = ParameterSet._int_prop(
        "OffsetJapanese", "오프셋 (일본어): -100% - 100%", -100, 100
    )
    offset_other = ParameterSet._int_prop(
        "OffsetOther", "오프셋 (기타): -100% - 100%", -100, 100
    )
    offset_symbol = ParameterSet._int_prop(
        "OffsetSymbol", "오프셋 (심벌): -100% - 100%", -100, 100
    )
    offset_user = ParameterSet._int_prop(
        "OffsetUser", "오프셋 (사용자): -100% - 100%", -100, 100
    )

    # Boolean properties
    bold = ParameterSet._bool_prop("Bold", "Bold: 0 = off, 1 = on")
    italic = ParameterSet._bool_prop("Italic", "Italic: 0 = off, 1 = on")
    small_caps = ParameterSet._bool_prop("SmallCaps", "Small Caps: 0 = off, 1 = on")
    emboss = ParameterSet._bool_prop("Emboss", "Emboss: 0 = off, 1 = on")
    engrave = ParameterSet._bool_prop("Engrave", "Engrave: 0 = off, 1 = on")
    superscript = ParameterSet._bool_prop("SuperScript", "Superscript: 0 = off, 1 = on")
    subscript = ParameterSet._bool_prop("SubScript", "Subscript: 0 = off, 1 = on")

    # Underline type (mapped)
    underline_type = ParameterSet._mapped_prop(
        "UnderlineType",
        UNDERLINE_TYPE_MAP,
        "밑줄 종류: 0 = none, 1 = bottom, 2 = center, 3 = top",
    )
    underline_shape = ParameterSet._int_prop("UnderlineShape", "선모양")

    # Outline type (mapped)

    outline_type = ParameterSet._mapped_prop(
        "OutLineType",
        OUTLINE_TYPE_MAP,
        "외곽선 종류: 0 = none, 1 = solid, 2 = dot, 3 = thick, 4 = dash, 5 = dashdot, 6 = dashdotdot",
    )

    # Shadow type (mapped)
    shadow_type = ParameterSet._mapped_prop(
        "ShadowType",
        SHADOW_TYPE_MAP,
        "그림자 종류: 0 = none, 1 = drop, 2 = continuous",
    )

    # Color properties
    text_color = ParameterSet._color_prop("TextColor", "글자색 (COLORREF)")
    shade_color = ParameterSet._color_prop("ShadeColor", "음영색 (COLORREF)")
    underline_color = ParameterSet._color_prop("UnderlineColor", "밑줄 색상 (COLORREF)")
    shadow_color = ParameterSet._color_prop("ShadowColor", "그림자 색 (COLORREF)")

    # Shadow offset properties (-100% ~ 100%)
    shadow_offset_x = ParameterSet._int_prop(
        "ShadowOffsetX", "그림자 간격 (X 방향): -100% - 100%", -100, 100
    )
    shadow_offset_y = ParameterSet._int_prop(
        "ShadowOffsetY", "그림자 간격 (Y 방향): -100% - 100%", -100, 100
    )

    # Strikeout properties
    strikeout_color = ParameterSet._color_prop("StrikeOutColor", "취소선 색 (COLORREF)")

    strikeout_type = ParameterSet._mapped_prop(
        "StrikeOutType",
        STRIKEOUT_TYPE_MAP,
        "취소선 종류: 0 = none, 1 = red single, 2 = red double, 3 = text single, 4 = text double",
    )
    strikeout_shape = ParameterSet._int_prop("StrikeOutShape", "선모양")

    # DiacSymMark (mapped)
    diac_sym_mark = ParameterSet._mapped_prop(
        "DiacSymMark",
        DIAC_SYM_MARK_MAP,
        "강조점 종류: 0 = none, 1 = black circle, 2 = empty circle",
    )

    # UseFontSpace (mapped)
    use_font_space = ParameterSet._mapped_prop(
        "UseFontSpace", USE_FONT_SPACE_MAP, "글꼴에 어울리는 빈칸: 0 = off, 1 = on"
    )

    # UseKerning (mapped)
    use_kerning = ParameterSet._mapped_prop(
        "UseKerning", USE_KERNING_MAP, "커닝: 0 = off, 1 = on"
    )

    # Height property
    height = ParameterSet._unit_prop("Height", "pt", "글자 크기 (HWPUNIT)")

    # BorderFill property (explicit)
    border_fill    = ParameterSet._typed_prop("BorderFill", "테두리/채우기 속성", lambda: BorderFill)

    # Aggregated properties for convenience
    @property
    def facename(self):
        return {
            "한글": self.facename_hangul,
            "영어": self.facename_latin,
            "한자": self.facename_hanja,
            "일어": self.facename_japanese,
            "기타": self.facename_other,
            "기호": self.facename_symbol,
            "사용자": self.facename_user,
        }

    @facename.setter
    def facename(self, value):
        keys = [
            "facename_hangul",
            "facename_latin",
            "facename_hanja",
            "facename_japanese",
            "facename_other",
            "facename_symbol",
            "facename_user",
        ]
        if isinstance(value, str):
            for key in keys:
                setattr(self, key, value)
        elif isinstance(value, list):
            for key, val in zip(keys, value):
                setattr(self, key, val)

    @property
    def fonttype(self):
        return {
            "한글": self.fonttype_hangul,
            "영어": self.fonttype_latin,
            "한자": self.fonttype_hanja,
            "일어": self.fonttype_japanese,
            "기타": self.fonttype_other,
            "기호": self.fonttype_symbol,
            "사용자": self.fonttype_user,
        }

    @fonttype.setter
    def fonttype(self, value):
        keys = [
            "fonttype_hangul",
            "fonttype_latin",
            "fonttype_hanja",
            "fonttype_japanese",
            "fonttype_other",
            "fonttype_symbol",
            "fonttype_user",
        ]
        if isinstance(value, int):
            for key in keys:
                setattr(self, key, value)
        elif isinstance(value, list):
            for key, val in zip(keys, value):
                setattr(self, key, val)

    @property
    def size(self):
        return {
            "한글": self.size_hangul,
            "영어": self.size_latin,
            "한자": self.size_hanja,
            "일어": self.size_japanese,
            "기타": self.size_other,
            "기호": self.size_symbol,
            "사용자": self.size_user,
        }

    @size.setter
    def size(self, value):
        keys = [
            "size_hangul",
            "size_latin",
            "size_hanja",
            "size_japanese",
            "size_other",
            "size_symbol",
            "size_user",
        ]
        if isinstance(value, int):
            for key in keys:
                setattr(self, key, value)
        elif isinstance(value, list):
            for key, val in zip(keys, value):
                setattr(self, key, val)

    @property
    def ratio(self):
        return {
            "한글": self.ratio_hangul,
            "영어": self.ratio_latin,
            "한자": self.ratio_hanja,
            "일어": self.ratio_japanese,
            "기타": self.ratio_other,
            "기호": self.ratio_symbol,
            "사용자": self.ratio_user,
        }

    @ratio.setter
    def ratio(self, value):
        keys = [
            "ratio_hangul",
            "ratio_latin",
            "ratio_hanja",
            "ratio_japanese",
            "ratio_other",
            "ratio_symbol",
            "ratio_user",
        ]
        if isinstance(value, int):
            for key in keys:
                setattr(self, key, value)
        elif isinstance(value, list):
            for key, val in zip(keys, value):
                setattr(self, key, val)

    @property
    def spacing(self):
        return {
            "한글": self.spacing_hangul,
            "영어": self.spacing_latin,
            "한자": self.spacing_hanja,
            "일어": self.spacing_japanese,
            "기타": self.spacing_other,
            "기호": self.spacing_symbol,
            "사용자": self.spacing_user,
        }

    @spacing.setter
    def spacing(self, value):
        keys = [
            "spacing_hangul",
            "spacing_latin",
            "spacing_hanja",
            "spacing_japanese",
            "spacing_other",
            "spacing_symbol",
            "spacing_user",
        ]
        if isinstance(value, int):
            for key in keys:
                setattr(self, key, value)
        elif isinstance(value, list):
            for key, val in zip(keys, value):
                setattr(self, key, val)

    @property
    def offset(self):
        return {
            "한글": self.offset_hangul,
            "영어": self.offset_latin,
            "한자": self.offset_hanja,
            "일어": self.offset_japanese,
            "기타": self.offset_other,
            "기호": self.offset_symbol,
            "사용자": self.offset_user,
        }

    @offset.setter
    def offset(self, value):
        keys = [
            "offset_hangul",
            "offset_latin",
            "offset_hanja",
            "offset_japanese",
            "offset_other",
            "offset_symbol",
            "offset_user",
        ]
        if isinstance(value, int):
            for key in keys:
                setattr(self, key, value)
        elif isinstance(value, list):
            for key, val in zip(keys, value):
                setattr(self, key, val)

    def __str__(self):
        attributes = {
            "facename": self.facename, 
            "fonttype": self.fonttype,
            "size": self.size,
            "ratio": self.ratio,
            "spacing": self.spacing,
            "Offset": self.offset,
            "bold": self.bold,
            "italic": self.italic,
            "small_caps": self.small_caps,
            "emboss": self.emboss,
            "engrave": self.engrave,
            "superscript": self.superscript,
            "subscript": self.subscript,
            "underline_type": self.underline_type,
            "outline_type": self.outline_type,
            "shadow_type": self.shadow_type,
            "text_color": self.text_color,
            "shade_color": self.shade_color,
            "underline_colo": self.underline_color,
            "shadow_offset_x": self.shadow_offset_x,
            "shadow_offset_y": self.shadow_offset_y,
            "shadow_color": self.shadow_color,
            "strikeout_type": self.strikeout_type,
            "diac_sym_mark": self.diac_sym_mark,
            "use_font_space": self.use_font_space,
            "use_kerning": self.use_kerning,
            "height": self.height,
            "border_fill": self.border_fill.serialize() if self.border_fill else None,
            }
        data = {"name": self.__class__.__name__, "values": attributes}
        return pprint.pformat(data, indent=4, width=60)

    def __repr__(self):
        return self.__str__()

# %% ../nbs/02_api/02_parameters.ipynb 42
class CtrlData(ParameterSet):
    """
    ### CtrlData

    22) CtrlData : 제어 데이터

    | Item ID | Type      | SubType | Description          |
    |---------|-----------|---------|----------------------|
    | Name    | PIT_BSTR  |         | 제어 데이터의 이름.  |
    """
    name = ParameterSet._str_prop("Name", "제어 데이터의 이름.")



# %% ../nbs/02_api/02_parameters.ipynb 44
class DrawArcType(ParameterSet):
    """
    ### DrawArcType

    27) DrawArcType: 곡선 그리기의 필수적인 속성을 나타내는 클래스

    | Item ID  | Type       | SubType | Description |
    |----------|------------|---------|-------------|
    | Type     | PIT_UI     |         | 곡선 유형: 0 = 선, 1 = 필수곡선, 2 = 화살표 |
    | Interval | PIT_ARRAY  | PIT_I   | 곡선의 시작점과 끝점을 나타내는 배열 |
    """
    _ark_type_map = {"line": 0, "essential": 1, "arrow": 2}
    type = ParameterSet._mapped_prop("Type", _ark_type_map,
                                     doc="곡선 유형: 0 = 선, 1 = 필수곡선, 2 = 화살표")
    interval = ParameterSet._int_list_prop("Interval", "곡선의 시작점과 끝점을 나타내는 배열")



# %% ../nbs/02_api/02_parameters.ipynb 46
class DrawCoordInfo(ParameterSet):
    """
    ### DrawCoordInfo

    28) DrawCoordInfo : 그리기 좌표의 상세 정보

    CoordInfo(한글2005)에서 DrawCoordInfo로 이름이 변경되었습니다. 정보를 읽고 쓸 수 있도록 지원합니다.

    | Item ID | Type       | SubType | Description                                 |
    |---------|------------|---------|---------------------------------------------|
    | Count   | PIT_UI4    |         | 점의 개수                                  |
    | Point   | PIT_ARRAY  | PIT_I   | 좌표 Array (X1,Y1), (X2,Y2), ..., (Xn,Yn)   |
    | Line    | PIT_ARRAY  | PIT_UI1 | 선 정보 Array(점들에서 연결된 형태)          |
    """
    count = ParameterSet._int_prop("Count", "점의 개수: 정수 값을 입력하세요.")
    point = ParameterSet._tuple_list_prop("Point", "좌표 배열 (X1, Y1), (X2, Y2), ..., (Xn, Yn): 리스트 값을 입력하세요.")
    line  = ParameterSet._int_list_prop("Line", "선 정보 배열: 리스트 값을 입력하세요.")



# %% ../nbs/02_api/02_parameters.ipynb 48
class DrawCtrlHyperlink(ParameterSet):
    """
    ### DrawCtrlHyperlink

    29) DrawCtrlHyperlink : 그림 개체의 Hyperlink 정보

    CtrlHyperlink(한글2005)에서 DrawCtrlHyperlink로 이름이 변경되었습니다.

    | Item ID | Type      | SubType | Description                          |
    |---------|-----------|---------|--------------------------------------|
    | Command | PIT_BSTR  |         | Command String (명령 문자열)         |
    """
    command = ParameterSet._str_prop("Command", "Command String: 명령 문자열을 입력하세요.")



# %% ../nbs/02_api/02_parameters.ipynb 50
class DrawEditDetail(ParameterSet):
    """
    ### DrawEditDetail

    30) DrawEditDetail : 그림의 교정과 관련된 상세 설정

    | Item ID | Type   | SubType | Description |
    |---------|--------|---------|-------------|
    | Command | PIT_UI |         | Reserved    |
    | Index   | PIT_UI |         | 교점 정의의 인덱스 |
    | PointX  | PIT_I  |         | 교점의 X 좌표 |
    | PointY  | PIT_I  |         | 교점의 Y 좌표 |
    """
    command = ParameterSet._int_prop("Command", "Command: Reserved.")
    index   = ParameterSet._int_prop("Index", "Index: 교점 정의의 인덱스.")
    point_x = ParameterSet._int_prop("PointX", "PointX: 교점의 X 좌표.")
    point_y = ParameterSet._int_prop("PointY", "PointY: 교점의 Y 좌표.")


# %% ../nbs/02_api/02_parameters.ipynb 52
class DrawFillAttr(ParameterSet):
    """
    ### DrawFillAttr

    30) DrawEditDetail : 그림의 교정과 관련된 상세 설정

    | Item ID               | Type         | SubType   | Description                                                                                         |
    |-----------------------|--------------|-----------|-----------------------------------------------------------------------------------------------------|
    | Type                  | PIT_UI       |           | 배경 유형: 0 = 채우기 없음, 1 = 단색 또는 무늬 채우기, 2 = 그림, 3 = 그라데이션                      |
    | GradationType         | PIT_I        |           | 그라데이션 형태: 1 = 줄무늬형, 2 = 원형, 3 = 원뿔형, 4 = 사각형                                       |
    | GradationAngle        | PIT_I        |           | 그라데이션의 기울기(회전 각도)                                                                       |
    | GradationCenterX      | PIT_I        |           | 그라데이션의 가로 중심 (X 좌표)                                                                      |
    | GradationCenterY      | PIT_I        |           | 그라데이션의 세로 중심 (Y 좌표)                                                                      |
    | GradationStep         | PIT_I        |           | 그라데이션 단계 설정 (0..100)                                                                        |
    | GradationColorNum     | PIT_I        |           | 그라데이션의 색 수                                                                                  |
    | GradationColor        | PIT_ARRAY    | PIT_I     | 그라데이션의 색상 (시작색, 중간색들, 끝색), 길이는 2~10                                               |
    | GradationIndexPos     | PIT_ARRAY    | PIT_I     | 그라데이션 단계 색상들과의 위치                                                                      |
    | GradationStepCenter   | PIT_UI1      |           | 그라데이션 단계 설정의 중심 (0..100)                                                                 |
    | GradationAlpha        | PIT_UI1      |           | 그라데이션 투명도 (0..255)                                                                           |
    | WinBrushFaceColor     | PIT_UI       |           | 단색 (RGB 0x00BBGGRR)                                                                                |
    | WinBrushHatchColor    | PIT_UI       |           | 무늬 (RGB 0x00BBGGRR)                                                                                |
    | WinBrushFaceStyle     | PIT_I1       |           | 무늬 스타일 (0~6)                                                                                   |
    | WinBrushAlpha         | PIT_UI       |           | 단색/무늬 투명도 (0..255)                                                                             |
    | FileName              | PIT_BSTR     |           | 그림 파일 경로                                                                                      |
    | Embedded              | PIT_UI1      |           | 그림이 문서에 직접 삽입(TRUE) / 파일로 연결(FALSE)                                                    |
    | PicEffect             | PIT_UI1      |           | 그림 효과: 0 = 그대로, 1 = 그레이스케일, 2 = 흑백 효과                                               |
    | Brightness            | PIT_I1       |           | 명도 (-100 ~ 100)                                                                                   |
    | Contrast              | PIT_I1       |           | 대비 (-100 ~ 100)                                                                                   |
    | Reverse               | PIT_UI1      |           | 반전 유무 (0 또는 1)                                                                                |
    | DrawFillImageType     | PIT_I        |           | 배경 채우는 방식 (0~14)                                                                              |
    | SkipLeft              | PIT_UI       |           | 왼쪽 자르기                                                                                        |
    | SkipRight             | PIT_UI       |           | 오른쪽 자르기                                                                                      |
    | SkipTop               | PIT_UI       |           | 위 자르기                                                                                          |
    | SkipBottom            | PIT_UI       |           | 아래 자르기                                                                                        |
    | OriginalSizeX         | PIT_I        |           | 이미지 원본 크기 X                                                                                   |
    | OriginalSizeY         | PIT_I        |           | 이미지 원본 크기 Y                                                                                   |
    | InsideMarginLeft      | PIT_I4       |           | 이미지 안쪽 여백 (왼쪽)                                                                              |
    | InsideMarginRight     | PIT_I4       |           | 이미지 안쪽 여백 (오른쪽)                                                                            |
    | InsideMarginTop       | PIT_I4       |           | 이미지 안쪽 여백 (위)                                                                                |
    | InsideMarginBottom    | PIT_I4       |           | 이미지 안쪽 여백 (아래)                                                                              |
    | WindowsBrush          | PIT_UI1      |           | 면/무늬 브러시 여부 (0 또는 1)                                                                       |
    | GradationBrush        | PIT_UI1      |           | 그러데이션 브러시 여부 (0 또는 1)                                                                    |
    | ImageBrush            | PIT_UI1      |           | 그림 브러시 여부 (0 또는 1)                                                                          |
    | ImageCreateOnDrag     | PIT_UI1      |           | 그림 개체 생성 시 드래그 여부 (0 또는 1)                                                             |
    | ImageAlpha            | PIT_UI1      |           | 그림 개체/배경 투명도 (0..255)                                                                        |
    """

    # Basic Properties
    
    type = ParameterSet._mapped_prop("Type", BACKGROUND_TYPE_MAP,
                                     doc="배경 유형: 0 = 채우기 없음, 1 = 단색 또는 무늬 채우기, 2 = 그림, 3 = 그라데이션")
    gradation_type = ParameterSet._mapped_prop("GradationType", GRADATION_TYPE_MAP,
                                             doc="그라데이션 형태: 1 = 줄무늬형, 2 = 원형, 3 = 원뿔형, 4 = 사각형")
    gradation_angle = ParameterSet._int_prop("GradationAngle", "그라데이션의 기울기(회전 각도)")
    gradation_center_x = ParameterSet._int_prop("GradationCenterX", "그라데이션의 가로 중심 (X 좌표)")
    gradation_center_y = ParameterSet._int_prop("GradationCenterY", "그라데이션의 세로 중심 (Y 좌표)")
    gradation_step = ParameterSet._int_prop("GradationStep", "그라데이션 단계 설정 (0..100)", 0, 100)
    gradation_color_num = ParameterSet._int_prop("GradationColorNum", "그라데이션의 색 수")
    
    gradation_color = ParameterSet._gradation_color_prop("GradationColor", "그라데이션의 색상 (시작색, 중간색들, 끝색)")
    
    gradation_index_pos = ParameterSet._int_list_prop("GradationIndexPos", "그라데이션 단계 색상들과의 위치")
    gradation_step_center = ParameterSet._int_prop("GradationStepCenter", "그라데이션 단계 설정의 중심 (0..100)", 0, 100)
    gradation_alpha = ParameterSet._int_prop("GradationAlpha", "그라데이션 투명도", 0, 255)
    
    win_brush_face_color = ParameterSet._int_prop("WinBrushFaceColor", "단색 (RGB 0x00BBGGRR)", 0, 0xFFFFFF)
    win_brush_hatch_color = ParameterSet._int_prop("WinBrushHatchColor", "무늬 (RGB 0x00BBGGRR)", 0, 0xFFFFFF)
    win_brush_face_style = ParameterSet._int_prop("WinBrushFaceStyle", "무늬 스타일", 0, 6)
    win_brush_alpha = ParameterSet._int_prop("WinBrushAlpha", "단색/무늬 투명도", 0, 255)
    
    filename = ParameterSet._str_prop("FileName", "그림 파일 경로")
    embedded = ParameterSet._bool_prop("Embedded", "그림이 문서에 직접 삽입(TRUE) / 파일로 연결(FALSE)")
    _pic_effect_map = {"none": 0, "gray": 1, "black and white": 2}
    pic_effect = ParameterSet._mapped_prop("PicEffect", _pic_effect_map,
                                           doc="그림 효과: 0 = 실제 이미지 그대로, 1 = 그레이스케일, 2 = 흑백 효과")
    brightness = ParameterSet._int_prop("Brightness", "명도 (-100 ~ 100)", -100, 100)
    contrast = ParameterSet._int_prop("Contrast", "대비 (-100 ~ 100)", -100, 100)
    reverse = ParameterSet._bool_prop("Reverse", "반전 유무: 0 (FALSE) 또는 1 (TRUE)")
    draw_fill_image_type = ParameterSet._int_prop("DrawFillImageType", "배경을 채우는 방식", 0, 14)
    
    skip_left = ParameterSet._int_prop("SkipLeft", "왼쪽 자르기")
    skip_right = ParameterSet._int_prop("SkipRight", "오른쪽 자르기")
    skip_top = ParameterSet._int_prop("SkipTop", "위 자르기")
    skip_bottom = ParameterSet._int_prop("SkipBottom", "아래 자르기")
    
    original_size_x = ParameterSet._int_prop("OriginalSizeX", "이미지 원본 크기 X")
    original_size_y = ParameterSet._int_prop("OriginalSizeY", "이미지 원본 크기 Y")
    
    inside_margin_left = ParameterSet._int_prop("InsideMarginLeft", "이미지 안쪽 여백 (왼쪽)")
    inside_margin_right = ParameterSet._int_prop("InsideMarginRight", "이미지 안쪽 여백 (오른쪽)")
    inside_margin_top = ParameterSet._int_prop("InsideMarginTop", "이미지 안쪽 여백 (위)")
    inside_margin_bottom = ParameterSet._int_prop("InsideMarginBottom", "이미지 안쪽 여백 (아래)")
    
    windows_brush = ParameterSet._bool_prop("WindowsBrush", "면/무늬 브러시 여부 (0 또는 1)")
    gradation_brush = ParameterSet._bool_prop("GradationBrush", "그러데이션 브러시 여부 (0 또는 1)")
    image_brush = ParameterSet._bool_prop("ImageBrush", "그림 브러시 여부 (0 또는 1)")
    image_create_on_drag = ParameterSet._bool_prop("ImageCreateOnDrag", "마우스로 그림 개체 생성 여부 (0 또는 1)")
    image_alpha = ParameterSet._int_prop("ImageAlpha", "그림 개체/배경 투명도", 0, 255)


# %% ../nbs/02_api/02_parameters.ipynb 55
class DrawImageAttr(ParameterSet):
    """
    ### DrawImageAttr

    32) DrawImageAttr : 그림 개체 속성

    ImageAttr(한글2005)에서 DrawImageAttr로 이름이 변경되었다.
    그림 개체의 속성을 지정하기 위한 파라메터셋.
    DrawFillAttr에서 그림과 관련된 속성만 빼서 파라메터셋으로 지정되었다.
    (현재 DrawFillAttr와 상속관계가 지정되지 않음)

    | Item ID              | Type     | SubType   | Description                                                                                         |
    |----------------------|----------|-----------|-----------------------------------------------------------------------------------------------------|
    | FileName             | PIT_BSTR |           | ShapeObject의 배경을 그림으로 선택했을 경우 또는 그림개체일 경우의 그림파일 경로                    |
    | Embedded             | PIT_UI1  |           | 그림이 문서에 삽입(T)/링크(F)                                                                         |
    | PicEffect            | PIT_UI1  |           | 그림 효과: 0 = 그대로, 1 = 흑백, 2 = 세피아 등                                                      |
    | Brightness           | PIT_I1   |           | 명도 (-100 ~ 100)                                                                                   |
    | Contrast             | PIT_I1   |           | 밝기 (-100 ~ 100)                                                                                   |
    | Reverse              | PIT_UI1  |           | 반전 유무                                                                                           |
    | DrawFillImageType    | PIT_I    |           | 배경을 채우는 방식 (0~14)                                                                             |
    | SkipLeft             | PIT_UI   |           | 그림 개체일 경우에만 의미 있는 아이템, 왼쪽 자르기                                                  |
    | SkipRight            | PIT_UI   |           | 그림 개체일 경우에만 의미 있는 아이템, 오른쪽 자르기                                                |
    | SkipTop              | PIT_UI   |           | 그림 개체일 경우에만 의미 있는 아이템, 위 자르기                                                    |
    | SkipBottom           | PIT_UI   |           | 그림 개체일 경우에만 의미 있는 아이템, 아래 자르기                                                  |
    | OriginalSizeX        | PIT_UI   |           | 이미지 원본 크기 X                                                                                   |
    | OriginalSizeY        | PIT_UI   |           | 이미지 원본 크기 Y                                                                                   |
    | InsideMarginLeft     | PIT_I4   |           | 이미지 안쪽 여백 (왼쪽)                                                                              |
    | InsideMarginRight    | PIT_I4   |           | 이미지 안쪽 여백 (오른쪽)                                                                            |
    | InsideMarginTop      | PIT_I4   |           | 이미지 안쪽 여백 (위)                                                                                |
    | InsideMarginBottom   | PIT_I4   |           | 이미지 안쪽 여백 (아래)                                                                              |
    | WindowsBrush         | PIT_UI1  |           | 현재 선택된 brush의 type이 면/무늬 브러시 여부                                                       |
    | GradationBrush       | PIT_UI1  |           | 현재 선택된 brush의 type이 그러데이션 브러시 여부                                                    |
    | ImageBrush           | PIT_UI1  |           | 현재 선택된 brush의 type이 그림 브러시 여부                                                          |
    | ImageCreateOnDrag    | PIT_UI1  |           | 그림 개체 생성 시 마우스로 끌어 생성 여부 (한글2007에 새로 추가)                                      |
    | ImageAlpha           | PIT_UI1  |           | 그림 개체/배경 투명도 (0~255)                                                                         |
    """
    file_name = ParameterSet._str_prop("FileName", "그림 파일 경로")
    embedded = ParameterSet._bool_prop("Embedded", "그림이 문서에 삽입(T)/링크(F)")
    pic_effect = ParameterSet._mapped_prop("PicEffect", PIC_EFFECT_MAP,
                                           doc="그림 효과: 0 = 그대로, 1 = 흑백, 2 = 세피아 등")
    brightness = ParameterSet._int_prop("Brightness", "명도 (-100 ~ 100)", -100, 100)
    contrast = ParameterSet._int_prop("Contrast", "밝기 (-100 ~ 100)", -100, 100)
    reverse = ParameterSet._bool_prop("Reverse", "반전 유무: 0 (off) 또는 1 (on)")
    draw_fill_image_type = ParameterSet._int_prop("DrawFillImageType", "배경을 채우는 방식", 0, 14)
    
    skip_left = ParameterSet._int_prop("SkipLeft", "왼쪽 자르기")
    skip_right = ParameterSet._int_prop("SkipRight", "오른쪽 자르기")
    skip_top = ParameterSet._int_prop("SkipTop", "위 자르기")
    skip_bottom = ParameterSet._int_prop("SkipBottom", "아래 자르기")
    
    original_size_x = ParameterSet._int_prop("OriginalSizeX", "이미지 원본 크기 X")
    original_size_y = ParameterSet._int_prop("OriginalSizeY", "이미지 원본 크기 Y")
    
    inside_margin_left = ParameterSet._int_prop("InsideMarginLeft", "이미지 안쪽 여백 (왼쪽)")
    inside_margin_right = ParameterSet._int_prop("InsideMarginRight", "이미지 안쪽 여백 (오른쪽)")
    inside_margin_top = ParameterSet._int_prop("InsideMarginTop", "이미지 안쪽 여백 (위)")
    inside_margin_bottom = ParameterSet._int_prop("InsideMarginBottom", "이미지 안쪽 여백 (아래)")
    
    windows_brush = ParameterSet._bool_prop("WindowsBrush", "면/무늬 브러시 여부: 0 또는 1")
    gradation_brush = ParameterSet._bool_prop("GradationBrush", "그러데이션 브러시 여부: 0 또는 1")
    image_brush = ParameterSet._bool_prop("ImageBrush", "그림 브러시 여부: 0 또는 1")
    image_create_on_drag = ParameterSet._bool_prop("ImageCreateOnDrag", "그림 개체 생성 시 마우스로 끌어 생성 여부: 0 또는 1")
    image_alpha = ParameterSet._int_prop("ImageAlpha", "그림 개체/배경 투명도 (0~255)", 0, 255)



# %% ../nbs/02_api/02_parameters.ipynb 57
class DrawImageScissoring(ParameterSet):
    """
    ### DrawImageScissoring

    33) DrawImageScissoring : 그림 자르기의 좌표 정보

    ImageScissoring(한컴오피스 2005)에서 DrawImageScissoring으로 이름이 변경되었습니다.

    | Item ID       | Type    | SubType | Description          |
    |---------------|---------|---------|----------------------|
    | Xoffset       | PIT_I   |         | 자를 x좌표 오프셋      |
    | Yoffset       | PIT_I   |         | 자를 y좌표 오프셋      |
    | HandleIndex   | PIT_UI  |         | Reserved             |
    """
    x_offset = ParameterSet._int_prop("Xoffset", "자를 x좌표 오프셋: 정수 값을 입력하세요.")
    y_offset = ParameterSet._int_prop("Yoffset", "자를 y좌표 오프셋: 정수 값을 입력하세요.")
    handle_index = ParameterSet._int_prop("HandleIndex", "Reserved: 정수 값을 입력하세요.")


# %% ../nbs/02_api/02_parameters.ipynb 59
class DrawLayout(ParameterSet):
    """
    ### DrawLayout

    34) DrawLayout : 도형 레이아웃의 일반 속성

    | Item ID          | Type      | SubType | Description |
    |------------------|-----------|---------|-------------|
    | CreateNumPt      | PIT_UI    |         | 생성할 점의 수 |
    | CreatePt         | PIT_ARRAY | PIT_I   | 생성할 점의 좌표정보: POINT(x,y) 형식의 배열로, CreateNumPt * 2 개수만큼 구성 |
    | CurveSegmentInfo | PIT_ARRAY | PIT_UI1 | 곡선 세그먼트 정보 |
    """
    create_num_pt = ParameterSet._int_prop("CreateNumPt", "생성할 점의 수: 정수 값을 입력하세요.")
    create_pt = ParameterSet._tuple_list_prop("CreatePt", "생성할 점의 좌표정보: (x, y) 튜플의 리스트")
    curve_segment_info = ParameterSet._int_list_prop("CurveSegmentInfo", "곡선 세그먼트 정보: 정수 리스트")


# %% ../nbs/02_api/02_parameters.ipynb 61
class DrawLineAttr(ParameterSet):
    """
    ### DrawLineAttr

    35) DrawLineAttr : 도형 선의 속성

    | Item ID        | Type        | SubType | Description                                                 |
    |----------------|-------------|---------|-------------------------------------------------------------|
    | Color          | PMT_UINT32  |         | 선 색상, RGB color를 나타내기 위한 32비트 값 (0x00BBGGRR)    |
    | Style          | PMT_INT     |         | 선의 스타일                                                |
    | Width          | PMT_INT     |         | 선의 두께                                                  |
    | EndCap         | PMT_INT     |         | 선의 끝단                                                  |
    | HeadStyle      | PMT_INT     |         | 선의 시작 화살표 형태                                      |
    | TailStyle      | PMT_INT     |         | 선의 끝 화살표 형태                                        |
    | HeadSize       | PMT_INT     |         | 선의 시작 화살표 크기                                      |
    | TailSize       | PMT_INT     |         | 선의 끝 화살표 크기                                        |
    | HeadFill       | PMT_BOOL    |         | 선의 시작 화살표 채움 여부                                  |
    | TailFill       | PMT_BOOL    |         | 선의 끝 화살표 채움 여부                                    |
    | OutLineStyle   | PMT_UINT    |         | 외곽선 (안쪽/바깥쪽/중앙)                                   |
    | Alpha          | PIT_UI1     |         | 투명도 (한글 2007에 처음 추가됨)                            |
    """
    color         = ParameterSet._int_prop("Color", "선 색상 (RGB 0x00BBGGRR): 정수를 입력하세요.")
    style         = ParameterSet._int_prop("Style", "선의 스타일: 정수를 입력하세요.")
    width         = ParameterSet._int_prop("Width", "선의 두께: 정수를 입력하세요.")
    end_cap       = ParameterSet._int_prop("EndCap", "선의 끝단: 정수를 입력하세요.")
    head_style    = ParameterSet._int_prop("HeadStyle", "선의 시작 화살표 형태: 정수를 입력하세요.")
    tail_style    = ParameterSet._int_prop("TailStyle", "선의 끝 화살표 형태: 정수를 입력하세요.")
    head_size     = ParameterSet._int_prop("HeadSize", "선의 시작 화살표 크기: 정수를 입력하세요.")
    tail_size     = ParameterSet._int_prop("TailSize", "선의 끝 화살표 크기: 정수를 입력하세요.")
    head_fill     = ParameterSet._bool_prop("HeadFill", "선의 시작 화살표 채움 여부: 0 또는 1을 입력하세요.")
    tail_fill     = ParameterSet._bool_prop("TailFill", "선의 끝 화살표 채움 여부: 0 또는 1을 입력하세요.")
    outline_style = ParameterSet._int_prop("OutLineStyle", "외곽선 (안쪽/바깥쪽/중앙): 정수를 입력하세요.")
    alpha         = ParameterSet._int_prop("Alpha", "투명도: 정수를 입력하세요.")


# %% ../nbs/02_api/02_parameters.ipynb 63
class DrawRectType(ParameterSet):
    """
    ### DrawRectType

    36) DrawRectType : 사각형 도형의 속성

    | Item ID | Type    | SubType | Description                           |
    |---------|---------|---------|---------------------------------------|
    | Type    | PIT_UI  |         | 도형의 종류 지정 (0 ~ 50까지)          |
    """
    type = ParameterSet._int_prop("Type", "도형의 종류: 0 ~ 50 사이의 정수 값을 입력하세요.", 0, 50)



# %% ../nbs/02_api/02_parameters.ipynb 65
class DrawResize(ParameterSet):
    """
    ### DrawResize

    37) DrawResize : 도형 크기 조정 Resizing 정보

    | Item ID      | Type    | SubType | Description                   |
    |--------------|---------|---------|-------------------------------|
    | Xoffset      | PIT_I   |         | 도형 크기 조정 X좌표 오프셋    |
    | Yoffset      | PIT_I   |         | 도형 크기 조정 Y좌표 오프셋    |
    | HandleIndex  | PIT_UI  |         | Reserved                      |
    | Mode         | PIT_UI  |         | Reserved                      |
    """
    x_offset = ParameterSet._int_prop("Xoffset", "도형 크기 조정 X좌표 오프셋: 정수 값을 입력하세요.")
    y_offset = ParameterSet._int_prop("Yoffset", "도형 크기 조정 Y좌표 오프셋: 정수 값을 입력하세요.")
    handle_index = ParameterSet._int_prop("HandleIndex", "Reserved: 정수 값을 입력하세요.")
    mode = ParameterSet._int_prop("Mode", "Reserved: 정수 값을 입력하세요.")


# %% ../nbs/02_api/02_parameters.ipynb 67
class DrawRotate(ParameterSet):
    """
    ### DrawRotate

    | Item ID         | Type   | Description                                  |
    |-----------------|--------|----------------------------------------------|
    | Command         | PIT_UI | 회전 설정의 기초 설정 (0: 없음, 1: 설정된 회전, 2: 그림 중심 회전, 3: 회전과 중심) |
    | CenterX         | PIT_I  | 회전 중심의 X 좌표                           |
    | CenterY         | PIT_I  | 회전 중심의 Y 좌표                           |
    | ObjectCenterX   | PIT_I  | 그림 중심의 X 좌표                           |
    | ObjectCenterY   | PIT_I  | 그림 중심의 Y 좌표                           |
    | Angle           | PIT_I  | 회전 각도                                    |
    | RotateImage     | PIT_UI1| 그림 회전 여부 (0: 회전 안 함, 1: 회전함)     |
    """
    command         = ParameterSet._mapped_prop("Command", ROTATION_SETTING_MAP,
                                                doc="회전 설정의 기초 설정 (0: 없음, 1: 설정된 회전, 2: 그림 중심 회전, 3: 회전과 중심)")
    center_x        = ParameterSet._int_prop("CenterX", "회전 중심의 X 좌표.")
    center_y        = ParameterSet._int_prop("CenterY", "회전 중심의 Y 좌표.")
    object_center_x = ParameterSet._int_prop("ObjectCenterX", "그림 중심의 X 좌표.")
    object_center_y = ParameterSet._int_prop("ObjectCenterY", "그림 중심의 Y 좌표.")
    angle           = ParameterSet._int_prop("Angle", "회전 각도.")
    rotate_image    = ParameterSet._bool_prop("RotateImage", "그림 회전 여부 (0: 회전 안 함, 1: 회전함).")



# %% ../nbs/02_api/02_parameters.ipynb 69
class DrawScAction(ParameterSet):
    """
    ### DrawScAction

    39) DrawScAction : 회전 중심과 90도 회전, 좌우/상하 플립 설정

    ScAction(한글2005)에서 DrawScAction으로 이름이 변경되었습니다.

    | Item ID        | Type    | SubType | Description                 |
    |----------------|---------|---------|-----------------------------|
    | RotateCenterX  | PIT_I4  |         | 회전 중심 X 좌표           |
    | RotateCenterY  | PIT_I4  |         | 회전 중심 Y 좌표           |
    | RotateAngel    | PIT_I   |         | 회전각                     |
    | HorzFlip       | PIT_UI  |         | 수평 flip (좌우 대칭 설정) |
    | VertFlip       | PIT_UI  |         | 수직 flip (상하 대칭 설정) |
    """
    rotate_center_x = ParameterSet._int_prop("RotateCenterX", "회전 중심 X 좌표")
    rotate_center_y = ParameterSet._int_prop("RotateCenterY", "회전 중심 Y 좌표")
    rotate_angle    = ParameterSet._int_prop("RotateAngel", "회전각")
    horz_flip       = ParameterSet._bool_prop("HorzFlip", "수평 flip (좌우 대칭 설정)")
    vert_flip       = ParameterSet._bool_prop("VertFlip", "수직 flip (상하 대칭 설정)")



# %% ../nbs/02_api/02_parameters.ipynb 71
class DrawShadow(ParameterSet):
    """
    ### DrawShadow

    40) DrawShadow : 그림자 효과 정보

    | Item ID       | Type     | SubType | Description                                     |
    |---------------|----------|---------|-------------------------------------------------|
    | ShadowType    | PIT_I4   |         | 그림자 종류: 0 = none, 1 = drop, 2 = continuous   |
    | ShadowColor   | PIT_UI4  |         | 그림자 색상 (COLORREF)                           |
    | ShadowOffsetX | PIT_I4   |         | 그림자 X축 오프셋 (-48% ~ 48%)                   |
    | ShadowOffsetY | PIT_I4   |         | 그림자 Y축 오프셋 (-48% ~ 48%)                   |
    | ShadowAlpha   | PIT_UI1  |         | 그림자 투명도 (0 ~ 255)                          |
    """
    shadow_type    = ParameterSet._mapped_prop("ShadowType", SHADOW_TYPE_MAP,
                                              doc="그림자 종류: 0 = none, 1 = drop, 2 = continuous")
    shadow_color   = ParameterSet._int_prop("ShadowColor", "그림자 색상 (COLORREF): 정수를 입력하세요.")
    shadow_offset_x = ParameterSet._int_prop("ShadowOffsetX", "그림자 X축 오프셋 (-48% ~ 48%)", -48, 48)
    shadow_offset_y = ParameterSet._int_prop("ShadowOffsetY", "그림자 Y축 오프셋 (-48% ~ 48%)", -48, 48)
    shadow_alpha   = ParameterSet._int_prop("ShadowAlpha", "그림자 투명도 (0 ~ 255)", 0, 255)


# %% ../nbs/02_api/02_parameters.ipynb 73
class DrawShear(ParameterSet):
    """
    ### DrawShear

    41) DrawShear : Shear transformation parameters

    | Item ID | Type   | SubType | Description        |
    |---------|--------|---------|--------------------|
    | XFactor | PIT_I  |         | X shear factor     |
    | YFactor | PIT_I  |         | Y shear factor     |
    """
    x_factor = ParameterSet._int_prop("XFactor", "X shear factor: 정수 값을 입력하세요.")
    y_factor = ParameterSet._int_prop("YFactor", "Y shear factor: 정수 값을 입력하세요.")



# %% ../nbs/02_api/02_parameters.ipynb 75
class DrawTextart(ParameterSet):
    """
    ### DrawTextart

    42) DrawTextart : 텍스트아트 속성
    """
    string         = ParameterSet._str_prop("String", "텍스트아트 내용: 문자열 값을 입력하세요.")
    font_name      = ParameterSet._str_prop("FontName", "폰트 이름.")
    font_style     = ParameterSet._str_prop("FontStyle", "폰트 스타일 (0 = Regular).")
    font_type      = ParameterSet._mapped_prop("FontType", FONTTYPE_MAP,
                                             doc="폰트 타입: 0 = don't care, 1 = TTF, 2 = HFT.")
    line_spacing   = ParameterSet._int_prop("LineSpacing", "줄 간격 (50 ~ 500).", 50, 500)
    char_spacing   = ParameterSet._int_prop("CharSpacing", "문자 간격 (50 ~ 500).", 50, 500)
    align_type     = ParameterSet._int_prop("AlignType", "정렬 유형.")
    shape          = ParameterSet._int_prop("Shape", "형태 (0 ~ 54).", 0, 54)
    shadow_type    = ParameterSet._mapped_prop("ShadowType", SHADOW_TYPE_MAP,
                                              doc="그림자 유형: 0 = none, 1 = drop, 2 = continuous.")
    shadow_offset_x = ParameterSet._int_prop("ShadowOffsetX", "그림자 X 오프셋 (-48 ~ 48).", -48, 48)
    shadow_offset_y = ParameterSet._int_prop("ShadowOffsetY", "그림자 Y 오프셋 (-48 ~ 48).", -48, 48)
    shadow_color   = ParameterSet._int_prop("ShadowColor", "그림자 색상 (RGB 32비트).")
    number_of_lines = ParameterSet._int_prop("NumberOfLines", "텍스트아트의 줄 수.")



# %% ../nbs/02_api/02_parameters.ipynb 77
class FindReplace(ParameterSet):
    """
    ### FindReplace

    56) FindReplace : 찾기/찾아 바꾸기

    | Item ID           | Type      | SubType | Description                                                               |
    |-------------------|-----------|---------|---------------------------------------------------------------------------|
    | FindString        | PIT_BSTR  |         | 찾을 문자열                                                              |
    | ReplaceString     | PIT_BSTR  |         | 바꿀 문자열                                                              |
    | Direction         | PIT_UI1   |         | 찾을 방향 : 0 = 아래쪽, 1 = 위쪽, 2 = 문서 전체                           |
    | MatchCase         | PIT_UI1   |         | 대소문자 구별 (on/off)                                                     |
    | AllWordForms      | PIT_UI1   |         | 모든 단어 형태 (on/off)                                                   |
    | SeveralWords      | PIT_UI1   |         | 여러 단어 찾기 (on/off)                                                    |
    | UseWildCards      | PIT_UI1   |         | 와일드카드 사용 (on/off)                                                   |
    | WholeWordOnly     | PIT_UI1   |         | 전체 단어만 찾기 (on/off)                                                   |
    | AutoSpell         | PIT_UI1   |         | 자동 맞춤법 사용 (on/off)                                                  |
    | ReplaceMode       | PIT_UI1   |         | 찾아 바꾸기 모드 (on/off)                                                  |
    | IgnoreFindString  | PIT_UI1   |         | 찾을 문자열 무시 (on/off)                                                  |
    | IgnoreReplaceString| PIT_UI1  |         | 바꿀 문자열 무시 (on/off)                                                   |
    | FindCharShape     | PIT_SET   | CharShape | 찾을 글자 모양                                                          |
    | FindParaShape     | PIT_SET   | ParaShape | 찾을 문단 모양                                                          |
    | ReplaceCharShape  | PIT_SET   | CharShape | 바꿀 글자 모양                                                          |
    | ReplaceParaShape  | PIT_SET   | ParaShape | 바꿀 문단 모양                                                          |
    | FindStyle         | PIT_BSTR  |         | 찾을 스타일                                                              |
    | ReplaceStyle      | PIT_BSTR  |         | 바꿀 스타일                                                              |
    | IgnoreMessage     | PIT_UI1   |         | 메시지박스 표시 안함 (on/off)                                              |
    | HanjaFromHangul   | PIT_UI1   |         | 한글임으로 한자 차기                                                      |
    | FindJaso          | PIT_UI1   |         | 자소로 찾기 (on/off)                                                      |
    | FindRegExp        | PIT_UI1   |         | 정규식(조건식)으로 찾기 (on/off)                                           |
    | FindType          | PIT_UI1   |         | 찾기 유형 (on/off)                                                       |
    """

    def __init__(self, parameterset=None):
        super().__init__(parameterset)
        self.attributes_names = [
            "find_string",
            "replace_string",
            "find_style",
            "replace_style",
            "direction",
            "match_case",
            "all_word_forms",
            "several_words",
            "use_wildcards",
            "whole_word_only",
            "auto_spell",
            "replace_mode",
            "ignore_find_string",
            "ignore_replace_string",
            "ignore_message",
            "hanja_from_hangul",
            "find_jaso",
            "find_regexp",
            "find_type",
            "find_charshape",
            "find_parashape",
            "replace_charshape",
            "replace_parashape",
        ]

    # String properties
    find_string = ParameterSet._str_prop("FindString", "찾을 문자열")
    replace_string = ParameterSet._str_prop("ReplaceString", "바꿀 문자열")
    find_style = ParameterSet._str_prop("FindStyle", "찾을 스타일")
    replace_style = ParameterSet._str_prop("ReplaceStyle", "바꿀 스타일")

    # Enum property for direction
    direction = ParameterSet._mapped_prop(
        "Direction",
        SEARCH_DIRECTION_MAP,
        doc="찾을 방향: 0 = 아래쪽, 1 = 위쪽, 2 = 문서 전체",
    )

    # Boolean properties (on/off flags)
    match_case = ParameterSet._bool_prop("MatchCase", "대소문자 구별 (on/off)")
    all_word_forms = ParameterSet._bool_prop("AllWordForms", "모든 단어 형태 (on/off)")
    several_words = ParameterSet._bool_prop("SeveralWords", "여러 단어 찾기 (on/off)")
    use_wildcards = ParameterSet._bool_prop("UseWildCards", "와일드카드 사용 (on/off)")
    whole_word_only = ParameterSet._bool_prop(
        "WholeWordOnly", "전체 단어만 찾기 (on/off)"
    )
    auto_spell = ParameterSet._bool_prop("AutoSpell", "자동 맞춤법 사용 (on/off)")
    replace_mode = ParameterSet._bool_prop("ReplaceMode", "찾아 바꾸기 모드 (on/off)")
    ignore_find_string = ParameterSet._bool_prop(
        "IgnoreFindString", "찾을 문자열 무시 (on/off)"
    )
    ignore_replace_string = ParameterSet._bool_prop(
        "IgnoreReplaceString", "바꿀 문자열 무시 (on/off)"
    )
    ignore_message = ParameterSet._bool_prop(
        "IgnoreMessage", "메시지박스 표시 안함 (on/off)"
    )
    hanja_from_hangul = ParameterSet._bool_prop(
        "HanjaFromHangul", "한글임으로 한자 차기"
    )
    find_jaso = ParameterSet._bool_prop("FindJaso", "자소로 찾기 (on/off)")
    find_regexp = ParameterSet._bool_prop("FindRegExp", "정규식 찾기 (on/off)")
    find_type = ParameterSet._bool_prop("FindType", "찾기 유형 (on/off)")

    # Composite properties using _typed_prop
    find_charshape = ParameterSet._typed_prop(
        "FindCharShape", "찾을 글자 모양", lambda: CharShape
    )
    find_parashape = ParameterSet._typed_prop(
        "FindParaShape", "찾을 문단 모양", lambda: ParaShape
    )
    replace_charshape = ParameterSet._typed_prop(
        "ReplaceCharShape", "바꿀 글자 모양", lambda: CharShape
    )
    replace_parashape = ParameterSet._typed_prop(
        "ReplaceParaShape", "바꿀 문단 모양", lambda: ParaShape
    )

# %% ../nbs/02_api/02_parameters.ipynb 79
class ListProperties(ParameterSet):
    """
    ### ListProperties

    76) ListProperties : 셀 리스트의 속성

    | Item ID       | Type     | SubType | Description                                      |
    |---------------|----------|---------|--------------------------------------------------|
    | TextDirection | PIT_UI1  |         | 글자 방향 (세로 쓰기 여부를 미정)                |
    | LineWrap      | PIT_UI1  |         | 강제에서 줄 바꿈 0 = 줄바꿈 없는 기본값           |
    | VertAlign     | PIT_UI1  |         | 세로 정렬 0 = 위 정렬                             |
    | MarginLeft    | PIT_I4   |         | 왼쪽 여백                                       |
    | MarginRight   | PIT_I4   |         | 오른쪽 여백                                     |
    | MarginTop     | PIT_I4   |         | 위쪽 여백                                       |
    | MarginBottom  | PIT_I4   |         | 아래쪽 여백                                     |
    """
    text_direction = ParameterSet._mapped_prop("TextDirection", TEXT_DIRECTION_MAP,
                                               doc="글자 방향: 0 = 기본값, 1 = 세로 쓰기")
    line_wrap = ParameterSet._mapped_prop("LineWrap", LINE_WRAP_MAP,
                                          doc="줄 바꿈 옵션: 0 = 기본값, 1 = 줄 바꿈 없음, 2 = 강제 줄 바꿈")
    vert_align = ParameterSet._mapped_prop("VertAlign", VERT_ALIGN_MAP,
                                           doc="세로 정렬: 0 = 위, 1 = 가운데, 2 = 아래")
    margin_left = ParameterSet._int_prop("MarginLeft", "왼쪽 여백: 정수 값을 입력하세요.")
    margin_right = ParameterSet._int_prop("MarginRight", "오른쪽 여백: 정수 값을 입력하세요.")
    margin_top = ParameterSet._int_prop("MarginTop", "위쪽 여백: 정수 값을 입력하세요.")
    margin_bottom = ParameterSet._int_prop("MarginBottom", "아래쪽 여백: 정수 값을 입력하세요.")



# %% ../nbs/02_api/02_parameters.ipynb 81
class NumberingShape(ParameterSet):
    """
    ### NumberingShape

    | Item ID                                  | Type      | SubType   | Description                                           |
    |------------------------------------------|-----------|-----------|-------------------------------------------------------|
    | HasCharShapeLevel0 ~ HasCharShapeLevel6   | PIT_UI1   |           | 7단 수준별 지정 여부 (0 = 기본값, 1 = 지정)           |
    | CharShapeLevel0 ~ CharShapeLevel6         | PIT_SET   | CharShape | 수준별 글자 모양 지정                                 |
    | WidthAdjustLevel0 ~ WidthAdjustLevel6     | PIT_I     |           | 수준별 너비 조정 값 (HWPUNIT)                         |
    | TextOffsetLevel0 ~ TextOffsetLevel6       | PIT_I     |           | 수준별 텍스트 오프셋 (percent or HWPUNIT)              |
    | AlignmentLevel0 ~ AlignmentLevel6         | PIT_UI1   |           | 수준별 정렬 (0 = 왼쪽, 1 = 가운데, 2 = 오른쪽)         |
    | UseInstWidthLevel0 ~ UseInstWidthLevel6     | PIT_UI1   |           | 수준별 너비를 문서 내부 너비에 맞출지 여부             |
    | AutoIndentLevel0 ~ AutoIndentLevel6       | PIT_UI1   |           | 수준별 자동 들여쓰기 여부                             |
    | TextOffsetTypeLevel0 ~ TextOffsetTypeLevel6 | PIT_UI1   |           | 텍스트 오프셋 타입 (0 = 기본값, 1 = HWPUNIT)            |
    | StrFormatLevel0 ~ StrFormatLevel6         | PIT_BSTR  |           | 수준별 문자열 포맷                                   |
    | NumFormatLevel0 ~ NumFormatLevel6         | PIT_UI1   |           | 수준별 번호 포맷 (0 또는 1)                            |
    | StartNumber                              | PIT_UI2   |           | 시작 번호 (0 = 기본값, n = 지정 번호)                 |
    | NewList                                  | PIT_UI1   |           | 새 목록 생성 여부                                   |
    """
    start_number = ParameterSet._int_prop("StartNumber", "시작 번호 (0 = 기본값, n = 지정 번호)")
    new_list     = ParameterSet._bool_prop("NewList", "새 목록 생성 여부 (0 = off, 1 = on)")

    # Level 0 properties
    has_char_shape_level0  = ParameterSet._bool_prop("HasCharShapeLevel0", "수준0 지정 여부 (0 = 기본값, 1 = 지정)")
    char_shape_level0      = ParameterSet._typed_prop("CharShapeLevel0", "수준0 글자 모양 지정", lambda: CharShape)
    width_adjust_level0    = ParameterSet._int_prop("WidthAdjustLevel0", "수준0 너비 조정 값 (HWPUNIT)")
    text_offset_level0     = ParameterSet._int_prop("TextOffsetLevel0", "수준0 텍스트 오프셋 (percent or HWPUNIT)")
    alignment_level0       = ParameterSet._mapped_prop("AlignmentLevel0", ALIGNMENT_MAP,
                                                     doc="수준0 정렬: 0 = 왼쪽, 1 = 가운데, 2 = 오른쪽")
    use_inst_width_level0  = ParameterSet._bool_prop("UseInstWidthLevel0", "수준0 문서 내부 너비 맞춤 여부")
    auto_indent_level0     = ParameterSet._bool_prop("AutoIndentLevel0", "수준0 자동 들여쓰기 여부")
    text_offset_type_level0 = ParameterSet._bool_prop("TextOffsetTypeLevel0", "수준0 텍스트 오프셋 타입 (0 = 기본값, 1 = HWPUNIT)")
    str_format_level0      = ParameterSet._str_prop("StrFormatLevel0", "수준0 문자열 포맷")
    num_format_level0      = ParameterSet._mapped_prop("NumFormatLevel0", NUMBER_FORMAT_MAP,
                                                     doc="수준0 번호 포맷 (0 또는 1)")

    # Level 1 properties
    has_char_shape_level1  = ParameterSet._bool_prop("HasCharShapeLevel1", "수준1 지정 여부")
    char_shape_level1      = ParameterSet._typed_prop("CharShapeLevel1", "수준1 글자 모양 지정", lambda: CharShape)
    width_adjust_level1    = ParameterSet._int_prop("WidthAdjustLevel1", "수준1 너비 조정 값 (HWPUNIT)")
    text_offset_level1     = ParameterSet._int_prop("TextOffsetLevel1", "수준1 텍스트 오프셋")
    alignment_level1       = ParameterSet._mapped_prop("AlignmentLevel1", ALIGNMENT_MAP,
                                                     doc="수준1 정렬: 0 = 왼쪽, 1 = 가운데, 2 = 오른쪽")
    use_inst_width_level1  = ParameterSet._bool_prop("UseInstWidthLevel1", "수준1 문서 내부 너비 맞춤 여부")
    auto_indent_level1     = ParameterSet._bool_prop("AutoIndentLevel1", "수준1 자동 들여쓰기 여부")
    text_offset_type_level1 = ParameterSet._bool_prop("TextOffsetTypeLevel1", "수준1 텍스트 오프셋 타입")
    str_format_level1      = ParameterSet._str_prop("StrFormatLevel1", "수준1 문자열 포맷")
    num_format_level1      = ParameterSet._mapped_prop("NumFormatLevel1", NUMBER_FORMAT_MAP,
                                                     doc="수준1 번호 포맷")

    # Level 2 properties
    has_char_shape_level2  = ParameterSet._bool_prop("HasCharShapeLevel2", "수준2 지정 여부")
    char_shape_level2      = ParameterSet._typed_prop("CharShapeLevel2", "수준2 글자 모양 지정", lambda: CharShape)
    width_adjust_level2    = ParameterSet._int_prop("WidthAdjustLevel2", "수준2 너비 조정 값 (HWPUNIT)")
    text_offset_level2     = ParameterSet._int_prop("TextOffsetLevel2", "수준2 텍스트 오프셋")
    alignment_level2       = ParameterSet._mapped_prop("AlignmentLevel2", ALIGNMENT_MAP,
                                                     doc="수준2 정렬: 0 = 왼쪽, 1 = 가운데, 2 = 오른쪽")
    use_inst_width_level2  = ParameterSet._bool_prop("UseInstWidthLevel2", "수준2 문서 내부 너비 맞춤 여부")
    auto_indent_level2     = ParameterSet._bool_prop("AutoIndentLevel2", "수준2 자동 들여쓰기 여부")
    text_offset_type_level2 = ParameterSet._bool_prop("TextOffsetTypeLevel2", "수준2 텍스트 오프셋 타입")
    str_format_level2      = ParameterSet._str_prop("StrFormatLevel2", "수준2 문자열 포맷")
    num_format_level2      = ParameterSet._mapped_prop("NumFormatLevel2", NUMBER_FORMAT_MAP,
                                                     doc="수준2 번호 포맷")

    # Level 3 properties
    has_char_shape_level3  = ParameterSet._bool_prop("HasCharShapeLevel3", "수준3 지정 여부")
    char_shape_level3      = ParameterSet._typed_prop("CharShapeLevel3", "수준3 글자 모양 지정", lambda: CharShape)
    width_adjust_level3    = ParameterSet._int_prop("WidthAdjustLevel3", "수준3 너비 조정 값 (HWPUNIT)")
    text_offset_level3     = ParameterSet._int_prop("TextOffsetLevel3", "수준3 텍스트 오프셋")
    alignment_level3       = ParameterSet._mapped_prop("AlignmentLevel3", ALIGNMENT_MAP,
                                                     doc="수준3 정렬: 0 = 왼쪽, 1 = 가운데, 2 = 오른쪽")
    use_inst_width_level3  = ParameterSet._bool_prop("UseInstWidthLevel3", "수준3 문서 내부 너비 맞춤 여부")
    auto_indent_level3     = ParameterSet._bool_prop("AutoIndentLevel3", "수준3 자동 들여쓰기 여부")
    text_offset_type_level3 = ParameterSet._bool_prop("TextOffsetTypeLevel3", "수준3 텍스트 오프셋 타입")
    str_format_level3      = ParameterSet._str_prop("StrFormatLevel3", "수준3 문자열 포맷")
    num_format_level3      = ParameterSet._mapped_prop("NumFormatLevel3", NUMBER_FORMAT_MAP,
                                                     doc="수준3 번호 포맷")

    # Level 4 properties
    has_char_shape_level4  = ParameterSet._bool_prop("HasCharShapeLevel4", "수준4 지정 여부")
    char_shape_level4      = ParameterSet._typed_prop("CharShapeLevel4", "수준4 글자 모양 지정", lambda: CharShape)
    width_adjust_level4    = ParameterSet._int_prop("WidthAdjustLevel4", "수준4 너비 조정 값 (HWPUNIT)")
    text_offset_level4     = ParameterSet._int_prop("TextOffsetLevel4", "수준4 텍스트 오프셋")
    alignment_level4       = ParameterSet._mapped_prop("AlignmentLevel4", ALIGNMENT_MAP,
                                                     doc="수준4 정렬: 0 = 왼쪽, 1 = 가운데, 2 = 오른쪽")
    use_inst_width_level4  = ParameterSet._bool_prop("UseInstWidthLevel4", "수준4 문서 내부 너비 맞춤 여부")
    auto_indent_level4     = ParameterSet._bool_prop("AutoIndentLevel4", "수준4 자동 들여쓰기 여부")
    text_offset_type_level4 = ParameterSet._bool_prop("TextOffsetTypeLevel4", "수준4 텍스트 오프셋 타입")
    str_format_level4      = ParameterSet._str_prop("StrFormatLevel4", "수준4 문자열 포맷")
    num_format_level4      = ParameterSet._mapped_prop("NumFormatLevel4", NUMBER_FORMAT_MAP,
                                                     doc="수준4 번호 포맷")

    # Level 5 properties
    has_char_shape_level5  = ParameterSet._bool_prop("HasCharShapeLevel5", "수준5 지정 여부")
    char_shape_level5      = ParameterSet._typed_prop("CharShapeLevel5", "수준5 글자 모양 지정", lambda: CharShape)
    width_adjust_level5    = ParameterSet._int_prop("WidthAdjustLevel5", "수준5 너비 조정 값 (HWPUNIT)")
    text_offset_level5     = ParameterSet._int_prop("TextOffsetLevel5", "수준5 텍스트 오프셋")
    alignment_level5       = ParameterSet._mapped_prop("AlignmentLevel5", ALIGNMENT_MAP,
                                                     doc="수준5 정렬: 0 = 왼쪽, 1 = 가운데, 2 = 오른쪽")
    use_inst_width_level5  = ParameterSet._bool_prop("UseInstWidthLevel5", "수준5 문서 내부 너비 맞춤 여부")
    auto_indent_level5     = ParameterSet._bool_prop("AutoIndentLevel5", "수준5 자동 들여쓰기 여부")
    text_offset_type_level5 = ParameterSet._bool_prop("TextOffsetTypeLevel5", "수준5 텍스트 오프셋 타입")
    str_format_level5      = ParameterSet._str_prop("StrFormatLevel5", "수준5 문자열 포맷")
    num_format_level5      = ParameterSet._mapped_prop("NumFormatLevel5", NUMBER_FORMAT_MAP,
                                                     doc="수준5 번호 포맷")

    # Level 6 properties
    has_char_shape_level6  = ParameterSet._bool_prop("HasCharShapeLevel6", "수준6 지정 여부")
    char_shape_level6      = ParameterSet._typed_prop("CharShapeLevel6", "수준6 글자 모양 지정", lambda: CharShape)
    width_adjust_level6    = ParameterSet._int_prop("WidthAdjustLevel6", "수준6 너비 조정 값 (HWPUNIT)")
    text_offset_level6     = ParameterSet._int_prop("TextOffsetLevel6", "수준6 텍스트 오프셋")
    alignment_level6       = ParameterSet._mapped_prop("AlignmentLevel6", ALIGNMENT_MAP,
                                                     doc="수준6 정렬: 0 = 왼쪽, 1 = 가운데, 2 = 오른쪽")
    use_inst_width_level6  = ParameterSet._bool_prop("UseInstWidthLevel6", "수준6 문서 내부 너비 맞춤 여부")
    auto_indent_level6     = ParameterSet._bool_prop("AutoIndentLevel6", "수준6 자동 들여쓰기 여부")
    text_offset_type_level6 = ParameterSet._bool_prop("TextOffsetTypeLevel6", "수준6 텍스트 오프셋 타입")
    str_format_level6      = ParameterSet._str_prop("StrFormatLevel6", "수준6 문자열 포맷")
    num_format_level6      = ParameterSet._mapped_prop("NumFormatLevel6", NUMBER_FORMAT_MAP,
                                                     doc="수준6 번호 포맷")

        



# %% ../nbs/02_api/02_parameters.ipynb 83
class ParaShape(ParameterSet):
    """
    ### ParaShape

    91) ParaShape : 문단 모양

    | Item ID          | Type    | SubType | Description |
    |------------------|---------|---------|-------------|
    | LeftMargin       | PIT_I4  |         | 왼쪽 여백 (URC) |
    | RightMargin      | PIT_I4  |         | 오른쪽 여백 (URC) |
    | Indentation      | PIT_I4  |         | 들여쓰기/내어 쓰기 (URC) |
    | PrevSpacing      | PIT_I4  |         | 문단 간격 위 (URC) |
    | NextSpacing      | PIT_I4  |         | 문단 간격 아래 (URC) |
    | LineSpacingType  | PIT_UI1 |         | 줄 간격 종류 (HWPUNIT): 0 = 글꼴 기준, 1 = 고정 값, 2 = 여백만 지정 |
    | LineSpacing      | PIT_I4  |         | 줄 간격 값 |
    | AlignType        | PIT_UI1 |         | 정렬 방식: 0 = 양쪽 정렬, 1 = 왼쪽 정렬, 2 = 오른쪽 정렬, 3 = 가운데 정렬, 4 = 배분 정렬, 5 = 나눔 정렬 |
    | BreakLatinWord   | PIT_UI1 |         | 줄 나눔 방식 (라틴): 0 = 단어, 1 = 하이픈, 2 = 글자 |
    | BreakNonLatinWord| PIT_UI1 |         | 줄 나눔 (비 라틴): 0 = 어절, 1 = 글자 |
    | SnapToGrid       | PIT_UI1 |         | 편집 용지의 줄 격자 사용 (on/off) |
    | Condense         | PIT_UI1 |         | 공백 최소값 (0 - 75%) |
    | WidowOrphan      | PIT_UI1 |         | 외톨이줄 보호 (on/off) |
    | KeepWithNext     | PIT_UI1 |         | 다음 문단과 함께 (on/off) |
    | KeepLinesTogether| PIT_UI1 |         | 문단 보호 (on/off) |
    | PagebreakBefore  | PIT_UI1 |         | 문단 앞에서 항상 쪽 나눔 (on/off) |
    | TextAlignment    | PIT_UI1 |         | 세로 정렬: 0 = 글꼴 기준, 1 = 위, 2 = 가운데, 3 = 아래 |
    | FontLineHeight   | PIT_UI1 |         | 글꼴에 어울리는 줄 높이 (on/off) |
    | HeadingType      | PIT_UI1 |         | 문단 머리 모양: 0 = 없음, 1 = 개요, 2 = 번호, 3 = 불릿 |
    | Level            | PIT_UI1 |         | 단계 (0 - 6) |
    | BorderConnect    | PIT_UI1 |         | 문단 테두리/배경 - 테두리 연결 (on/off) |
    | BorderText       | PIT_UI1 |         | 문단 테두리/배경 - 여백 무시: 0 = 단, 1 = 텍스트 |
    | BorderOffsetLeft | PIT_I   |         | 문단 테두리/배경 - 4방향 간격 (HWPUNIT): 왼쪽 |
    | BorderOffsetRight| PIT_I   |         | 문단 테두리/배경 - 4방향 간격 (HWPUNIT): 오른쪽 |
    | BorderOffsetTop  | PIT_I   |         | 문단 테두리/배경 - 4방향 간격 (HWPUNIT): 위 |
    | BorderOffsetBottom| PIT_I  |         | 문단 테두리/배경 - 4방향 간격 (HWPUNIT): 아래 |
    | TailType         | PIT_UI1 |         | 문단 꼬리 모양 (마지막 꼬리 줄 적용) (on/off) |
    | LineWrap         | PIT_UI1 |         | 글꼴에 어울리는 줄 높이 (on/off) |
    | TabDef           | PIT_SET | TabDef  | 탭 정의 |
    | Numbering        | PIT_SET | NumberingShape | 문단 번호 (머리 모양이 ‘개요’, ‘번호’일 때 사용) |
    | Bullet           | PIT_SET | BulletShape | 불릿 모양 (머리 모양이 ‘불릿’일 때 사용) |
    | BorderFill       | PIT_SET | BorderFill | 테두리/배경 |
    """

    def __init__(self, parameterset=None):
        super().__init__(parameterset)
        self.attributes_names = [
            "left_margin",
            "right_margin",
            "indentation",
            "prev_spacing",
            "next_spacing",
            "line_spacing_type",
            "line_spacing",
            "align_type",
            "break_latin_word",
            "break_non_latin_word",
            "snap_to_grid",
            "condense",
            "widow_orphan",
            "keep_with_next",
            "keep_lines_together",
            "pagebreak_before",
            "text_alignment",
            "font_line_height",
            "heading_type",
            "level",
            "border_connect",
            "border_text",
            "border_offset_left",
            "border_offset_right",
            "border_offset_top",
            "border_offset_bottom",
            "tail_type",
            "line_wrap",
            "tab_def",
            "numbering",
            "bullet",
            "border_fill",
        ]

    left_margin = ParameterSet._int_prop("LeftMargin", "왼쪽 여백 (URC)")
    right_margin = ParameterSet._int_prop("RightMargin", "오른쪽 여백 (URC)")
    indentation = ParameterSet._int_prop("Indentation", "들여쓰기/내어 쓰기 (URC)")
    prev_spacing = ParameterSet._int_prop("PrevSpacing", "문단 간격 위 (URC)")
    next_spacing = ParameterSet._int_prop("NextSpacing", "문단 간격 아래 (URC)")
    line_spacing_type = ParameterSet._mapped_prop(
        "LineSpacingType",
        LINE_SPACING_TYPE_MAP,
        doc="줄 간격 종류: 0 = 글꼴 기준, 1 = 고정 값, 2 = 여백만 지정",
    )
    line_spacing = ParameterSet._int_prop("LineSpacing", "줄 간격 값")
    align_type = ParameterSet._mapped_prop(
        "AlignType",
        ALIGN_TYPE_MAP,
        doc="정렬 방식: 0 = 양쪽 정렬, 1 = 왼쪽 정렬, 2 = 오른쪽 정렬, 3 = 가운데 정렬, 4 = 배분 정렬, 5 = 나눔 정렬",
    )
    break_latin_word = ParameterSet._mapped_prop(
        "BreakLatinWord",
        LATIN_LINE_BREAK_MAP,
        doc="줄 나눔 (라틴): 0 = 단어, 1 = 하이픈, 2 = 글자",
    )
    break_non_latin_word = ParameterSet._mapped_prop(
        "BreakNonLatinWord",
        NONLATIN_LINE_BREAK_MAP,
        "줄 나눔 (비 라틴): 0 = 어절, 1 = 글자",
    )
    snap_to_grid = ParameterSet._bool_prop(
        "SnapToGrid", "편집 용지의 줄 격자 사용 (on/off)"
    )
    condense = ParameterSet._int_prop("Condense", "공백 최소값 (0 - 75%)", 0, 75)
    widow_orphan = ParameterSet._bool_prop("WidowOrphan", "외톨이줄 보호 (on/off)")
    keep_with_next = ParameterSet._bool_prop(
        "KeepWithNext", "다음 문단과 함께 (on/off)"
    )
    keep_lines_together = ParameterSet._bool_prop(
        "KeepLinesTogether", "문단 보호 (on/off)"
    )
    pagebreak_before = ParameterSet._bool_prop(
        "PagebreakBefore", "문단 앞에서 항상 쪽 나눔 (on/off)"
    )
    text_alignment = ParameterSet._mapped_prop(
        "TextAlignment",
        TEXT_ALIGN_MAP,
        doc="세로 정렬: 0 = 글꼴 기준, 1 = 위, 2 = 가운데, 3 = 아래",
    )
    font_line_height = ParameterSet._bool_prop(
        "FontLineHeight", "글꼴에 어울리는 줄 높이 (on/off)"
    )
    heading_type = ParameterSet._mapped_prop(
        "HeadingType",
        HEADING_TYPE_MAP,
        doc="문단 머리 모양: 0 = 없음, 1 = 개요, 2 = 번호, 3 = 불릿",
    )
    level = ParameterSet._int_prop("Level", "단계 (0 - 6)", 0, 6)
    border_connect = ParameterSet._bool_prop(
        "BorderConnect", "문단 테두리/배경 - 테두리 연결 (on/off)"
    )
    border_text = ParameterSet._mapped_prop(
        "BorderText",
        BORDER_TEXT_MAP,
        doc="문단 테두리/배경 - 여백 무시: 0 = 단, 1 = 텍스트",
    )
    border_offset_left = ParameterSet._int_prop(
        "BorderOffsetLeft", "문단 테두리/배경 - 4방향 간격 (HWPUNIT): 왼쪽"
    )
    border_offset_right = ParameterSet._int_prop(
        "BorderOffsetRight", "문단 테두리/배경 - 4방향 간격 (HWPUNIT): 오른쪽"
    )
    border_offset_top = ParameterSet._int_prop(
        "BorderOffsetTop", "문단 테두리/배경 - 4방향 간격 (HWPUNIT): 위"
    )
    border_offset_bottom = ParameterSet._int_prop(
        "BorderOffsetBottom", "문단 테두리/배경 - 4방향 간격 (HWPUNIT): 아래"
    )
    tail_type = ParameterSet._bool_prop(
        "TailType", "문단 꼬리 모양 (마지막 꼬리 줄 적용) (on/off)"
    )
    line_wrap = ParameterSet._bool_prop("LineWrap", "글꼴에 어울리는 줄 높이 (on/off)")
    tab_def = ParameterSet._typed_prop("TabDef", "탭 정의", lambda: TabDef)
    numbering = ParameterSet._typed_prop(
        "Numbering", "문단 번호", lambda: NumberingShape
    )
    bullet = ParameterSet._typed_prop("Bullet", "불릿 모양", lambda: BulletShape)
    border_fill = ParameterSet._typed_prop(
        "BorderFill", "테두리/배경", lambda: BorderFill
    )

# %% ../nbs/02_api/02_parameters.ipynb 85
class ShapeObject(ParameterSet):
    """
    ### ShapeObject

    105) ShapeObject : 도형 개체의 속성 정의 (테이블, 수식, 그림 포함)

    이 객체는 한글의 도형 관련 속성을 조작하고 정의할 수 있으며, 도형의 크기, 위치, 스타일 등을 설정할 수 있습니다.

    | Item ID            | Type      | SubType   | Description                                   |
    |--------------------|-----------|-----------|-----------------------------------------------|
    | TreatAsChar        | PIT_UI1   |           | 글자처럼 처리 여부 (on/off)                    |
    | AffectsLine        | PIT_UI1   |           | 줄에 영향을 미치는지 여부 (on/off)             |
    | VertRelTo          | PIT_UI1   |           | 수직 기준 위치 설정                           |
    | VertAlign          | PIT_UI1   |           | 수직 정렬 방식                                |
    | VertOffset         | PIT_I4    |           | 수직 오프셋 (HWPUNIT)                          |
    | HorzRelTo          | PIT_UI1   |           | 수평 기준 위치 설정                           |
    | HorzAlign          | PIT_UI1   |           | 수평 정렬 방식                                |
    | HorzOffset         | PIT_I4    |           | 수평 오프셋 (HWPUNIT)                          |
    | FlowWithText       | PIT_UI1   |           | 텍스트 흐름에 따라 이동 여부 (on/off)           |
    | AllowOverlap       | PIT_UI1   |           | 겹침 허용 여부 (on/off)                        |
    | WidthRelTo         | PIT_UI1   |           | 너비 기준 위치 설정                           |
    | Width              | PIT_I4    |           | 도형의 너비                                   |
    | HeightRelTo        | PIT_UI1   |           | 높이 기준 위치 설정                           |
    | Height             | PIT_I4    |           | 도형의 높이                                   |
    | ProtectSize        | PIT_UI1   |           | 크기 보호 여부 (on/off)                        |
    | TextWrap           | PIT_UI1   |           | 텍스트 랩 설정                                |
    | TextFlow           | PIT_UI1   |           | 텍스트 흐름 방향                              |
    | OutsideMarginLeft  | PIT_I4    |           | 외부 여백 (왼쪽)                              |
    | OutsideMarginRight | PIT_I4    |           | 외부 여백 (오른쪽)                            |
    | OutsideMarginTop   | PIT_I4    |           | 외부 여백 (위)                                |
    | OutsideMarginBottom| PIT_I4    |           | 외부 여백 (아래)                              |
    | NumberingType      | PIT_UI1   |           | 번호 매기기 방식                              |
    | LayoutWidth        | PIT_I4    |           | 레이아웃 너비                                 |
    | LayoutHeight       | PIT_I4    |           | 레이아웃 높이                                 |
    | Lock               | PIT_UI1   |           | 잠금 여부 (on/off)                            |
    | HoldAnchorObj      | PIT_UI1   |           | 기준 객체 고정 여부                           |
    | PageNumber         | PIT_UI    |           | 페이지 번호                                   |
    | AdjustSelection    | PIT_UI1   |           | 선택 영역 조정 여부                           |
    | AdjustTextBox      | PIT_UI1   |           | 텍스트 박스 조정 여부                         |
    | AdjustPrevObjAttr  | PIT_UI1   |           | 이전 객체 속성 조정 여부                       |
    """
    def __init__(self, parameterset=None):
        super().__init__(parameterset)
        self.attributes_names = [
"treat_as_char", 
"affects_line", 
"vert_rel_to", 
"vert_align", 
"vert_offset", 
"horz_rel_to", 
"horz_align", 
"horz_offset", 
"flow_with_text", 
"allow_overlap", 
"width_rel_to", 
"width", 
"height_rel_to", 
"height", 
"protect_size", 
"text_wrap", 
"text_flow", 
"outside_margin_left", 
"outside_margin_right", 
"outside_margin_top", 
"outside_margin_bottom", 
"numbering_type", 
"layout_width", 
"layout_height", 
"lock", 
"hold_anchor_obj", 
"page_number", 
"adjust_selection", 
"adjust_text_box", 
"adjust_prev_obj_attr", 
"shape_draw_layout", 
"shape_draw_line_attr", 
"shape_draw_fill_attr", 
"shape_draw_image_attr", 
"shape_draw_rect_type", 
"shape_draw_arc_type", 
"shape_draw_resize", 
"shape_draw_rotate", 
"shape_draw_edit_detail", 
"shape_draw_image_scissoring", 
"shape_draw_sc_action", 
"shape_draw_ctrl_hyperlink", 
"shape_draw_coord_info", 
"shape_draw_shear", 
"shape_draw_textart", 
"shape_table_cell", 
"shape_list_properties", 
"shape_caption", 
        ]
            
    treat_as_char    = ParameterSet._bool_prop("TreatAsChar", "글자처럼 처리 여부 (on/off)")
    affects_line     = ParameterSet._bool_prop("AffectsLine", "줄에 영향을 미치는지 여부 (on/off)")
    vert_rel_to      = ParameterSet._mapped_prop("VertRelTo", VERT_REL_TO_MAP, doc="수직 기준 위치 설정")
    vert_align       = ParameterSet._mapped_prop("VertAlign", VERT_ALIGN_MAP, doc="수직 정렬 방식")
    vert_offset      = ParameterSet._int_prop("VertOffset", "수직 오프셋 (HWPUNIT)")
    horz_rel_to      = ParameterSet._mapped_prop("HorzRelTo", HORZ_REL_TO_MAP, doc="수평 기준 위치 설정")
    horz_align       = ParameterSet._mapped_prop("HorzAlign", HORZ_ALIGN_MAP, doc="수평 정렬 방식")
    horz_offset      = ParameterSet._int_prop("HorzOffset", "수평 오프셋 (HWPUNIT)")
    flow_with_text   = ParameterSet._bool_prop("FlowWithText", "텍스트 흐름에 따라 이동 여부 (on/off)")
    allow_overlap    = ParameterSet._bool_prop("AllowOverlap", "겹침 허용 여부 (on/off)")
    width_rel_to     = ParameterSet._mapped_prop("WidthRelTo", HORZ_REL_TO_MAP, doc="너비 기준 위치 설정")
    width            = ParameterSet._int_prop("Width", "도형의 너비. WidthRelTo 값에 따라 의미가 달라짐(absolute는 hwpunit 나머지는 퍼센트(%))")
    height_rel_to    = ParameterSet._mapped_prop("HeightRelTo", VERT_REL_TO_MAP, doc="높이 기준 위치 설정")
    height           = ParameterSet._int_prop("Height", "도형의 높이 HeightRelTo 값에 따라 의미가 달라짐(absolute는 hwpunit 나머지는 퍼센트(%))")
    protect_size     = ParameterSet._bool_prop("ProtectSize", "크기 보호 여부 (on/off)")
    text_wrap        = ParameterSet._mapped_prop("TextWrap", TEXT_WRAP_MAP, doc="텍스트 랩 설정")
    text_flow        = ParameterSet._mapped_prop("TextFlow", TEXT_FLOW_MAP, doc="텍스트 흐름 방향 그리기 개체의 좌/우 어느 쪽에 글을 배치할지 지정하는 옵션. TextWrap의 값이 0일 때만 유효하다. 0 = 양쪽 모두(Both) 1 = 왼쪽만(Left Only) 2 = 오른쪽만(Right Only) 3 = 왼쪽과 오른쪽 중 넓은 쪽(Largest Only)")
    outside_margin_left  = ParameterSet._unit_prop("OutsideMarginLeft", "mili", "외부 여백 (왼쪽)")
    outside_margin_right = ParameterSet._unit_prop("OutsideMarginRight", "mili", "외부 여백 (오른쪽)")
    horz_rel_to      = ParameterSet._mapped_prop("HorzRelTo", HORZ_REL_TO_MAP, doc="수평 기준 위치 설정")
    horz_align       = ParameterSet._mapped_prop("HorzAlign", HORZ_ALIGN_MAP, doc="수평 정렬 방식")
    horz_offset      = ParameterSet._int_prop("HorzOffset", "수평 오프셋 (HWPUNIT)")
    layout_width     = ParameterSet._int_prop("LayoutWidth", "레이아웃 너비")
    layout_height    = ParameterSet._int_prop("LayoutHeight", "레이아웃 높이")
    lock             = ParameterSet._bool_prop("Lock", "잠금 여부 (on/off)")
    hold_anchor_obj  = ParameterSet._bool_prop("HoldAnchorObj", "기준 객체 고정 여부")
    page_number      = ParameterSet._int_prop("PageNumber", "페이지 번호")
    adjust_selection = ParameterSet._bool_prop("AdjustSelection", "선택 영역 조정 여부")
    adjust_text_box  = ParameterSet._bool_prop("AdjustTextBox", "텍스트 박스 조정 여부")
    adjust_prev_obj_attr = ParameterSet._bool_prop("AdjustPrevObjAttr", "이전 객체 속성 조정 여부")

    # Composite properties using _typed_prop
    shape_draw_layout      = ParameterSet._typed_prop("ShapeDrawLayOut", "그리기 개체의 Layout", lambda: DrawLayout)
    shape_draw_line_attr   = ParameterSet._typed_prop("ShapeDrawLineAttr", "그리기 개체의 Line 속성", lambda: DrawLineAttr)
    shape_draw_fill_attr   = ParameterSet._typed_prop("ShapeDrawFillAttr", "그리기 개체의 Fill 속성", lambda: DrawFillAttr)
    shape_draw_image_attr  = ParameterSet._typed_prop("ShapeDrawImageAttr", "그림 개체 속성", lambda: DrawImageAttr)
    shape_draw_rect_type   = ParameterSet._typed_prop("ShapeDrawRectType", "사각형 그리기 개체 유형", lambda: DrawRectType)
    shape_draw_arc_type    = ParameterSet._typed_prop("ShapeDrawArcType", "호 그리기 개체 유형", lambda: DrawArcType)
    shape_draw_resize      = ParameterSet._typed_prop("ShapeDrawResize", "그리기 개체 리사이징", lambda: DrawResize)
    shape_draw_rotate      = ParameterSet._typed_prop("ShapeDrawRotate", "그리기 개체 회전", lambda: DrawRotate)
    shape_draw_edit_detail = ParameterSet._typed_prop("ShapeDrawEditDetail", "그리기 개체 EditDetail", lambda: DrawEditDetail)
    shape_draw_image_scissoring = ParameterSet._typed_prop("ShapeDrawImageScissoring", "그림 개체 자르기", lambda: DrawImageScissoring)
    shape_draw_sc_action   = ParameterSet._typed_prop("ShapeDrawScAction", "그리기 개체 회전/flip", lambda: DrawScAction)
    shape_draw_ctrl_hyperlink = ParameterSet._typed_prop("ShapeDrawCtrlHyperlink", "그리기 개체 하이퍼링크", lambda: DrawCtrlHyperlink)
    shape_draw_coord_info  = ParameterSet._typed_prop("ShapeDrawCoordInfo", "그리기 개체 좌표정보", lambda: DrawCoordInfo)
    shape_draw_shear       = ParameterSet._typed_prop("ShapeDrawShear", "그리기 개체 기울이기", lambda: DrawShear)
    shape_draw_textart     = ParameterSet._typed_prop("ShapeDrawTextart", "글맵시", lambda: DrawTextart)

    shape_table_cell       = ParameterSet._typed_prop("ShapeTableCell", "셀 정보", lambda: Cell)
    shape_list_properties  = ParameterSet._typed_prop("ShapeListProperties", "서브 list 속성", lambda: ListProperties)
    shape_caption          = ParameterSet._typed_prop("ShapeCaption", "캡션", lambda: Caption)





# %% ../nbs/02_api/02_parameters.ipynb 87
class TabDef(ParameterSet):
    """
    ### TabDef

    113) TabDef : 탭 정의

    | Item ID    | Type      | SubType | Description |
    |------------|-----------|---------|-------------|
    | AutoTabLeft| PIT_UI1   |         | 문단 왼쪽 끝 탭 (on / off) |
    | AutoTabRight| PIT_UI1  |         | 문단 오른쪽 끝 탭 (on / off) |
    | TabItem    | PIT_ARRAY | PIT_I   | 각각의 탭 정의. 하나의 탭 아이템은 세 개의 인수로 표현됨. (n*3+0: 탭 위치, n*3+1: 채울 모양, n*3+2: 탭 종류) |
    """
    auto_tab_left  = ParameterSet._bool_prop("AutoTabLeft", "문단 왼쪽 탭 설정 (on / off)")
    auto_tab_right = ParameterSet._bool_prop("AutoTabRight", "문단 오른쪽 탭 설정 (on / off)")
    tab_item       = ParameterSet._int_list_prop("TabItem", "탭 정의 목록 (정수 리스트)")




# %% ../nbs/02_api/02_parameters.ipynb 89
class Table(ParameterSet):
    """
    ### Table

    114) Table : 테이블 속성 정의

    | Item ID          | Type      | SubType         | Description                   |
    |------------------|-----------|-----------------|-------------------------------|
    | PageBreak        | PIT_UI1   |                 | 페이지 나눔 처리 방식         |
    | RepeatHeader     | PIT_UI1   |                 | 반복 헤더 여부 (on / off)      |
    | CellSpacing      | PIT_UI4   |                 | 셀 간격 (HWPUNIT)             |
    | CellMarginLeft   | PIT_I4    |                 | 셀 왼쪽 여백                 |
    | CellMarginRight  | PIT_I4    |                 | 셀 오른쪽 여백               |
    | CellMarginTop    | PIT_I4    |                 | 셀 위쪽 여백                 |
    | CellMarginBottom | PIT_I4    |                 | 셀 아래쪽 여백               |
    | BorderFill       | PIT_SET   | BorderFill      | 테두리/채우기 속성           |
    | TableCharInfo    | PIT_SET   | TableChartInfo  | 테이블 관련 문자 정보        |
    | TableBorderFill  | PIT_SET   | BorderFill      | 테이블 테두리 속성           |
    | Cell             | PIT_SET   | Cell            | 셀 정보                      |
    """
    page_break     = ParameterSet._mapped_prop("PageBreak", PAGE_BREAK_MAP,
                                               doc="표가 페이지 경계에 걸렸을 때의 처리 방식 0 = 나누지 않는다.  1 = 테이블은 나누지만 셀은 나누지 않는다. 2 = 셀 내의 텍스트도 나눈다.")
    repeat_header  = ParameterSet._bool_prop("RepeatHeader", "반복 헤더 여부 (on/off)")
    cell_spacing   = ParameterSet._int_prop("CellSpacing", "셀 간격 (HWPUNIT)")
    cell_margin_left  = ParameterSet._int_prop("CellMarginLeft", "셀 왼쪽 여백")
    cell_margin_right = ParameterSet._int_prop("CellMarginRight", "셀 오른쪽 여백")
    cell_margin_top   = ParameterSet._int_prop("CellMarginTop", "셀 위쪽 여백")
    cell_margin_bottom = ParameterSet._int_prop("CellMarginBottom", "셀 아래쪽 여백")
    border_fill    = ParameterSet._typed_prop("BorderFill", "테두리/채우기 속성", lambda: BorderFill)
    # table_char_info = ParameterSet._typed_prop("TableCharInfo", "테이블 관련 문자 정보", TableChartInfo) # Not available now.
    table_border_fill = ParameterSet._typed_prop("TableBorderFill", "테이블 테두리 속성", lambda: BorderFill)
    cell           = ParameterSet._typed_prop("Cell", "셀 정보", lambda: Cell)


